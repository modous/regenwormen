<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/backend/src/main/java/nl/hva/ewa/regenwormen/domain/errorForm/ErrorRecord.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/src/main/java/nl/hva/ewa/regenwormen/domain/errorForm/ErrorRecord.java" />
              <option name="originalContent" value="package nl.hva.ewa.regenwormen.domain.errorForm;&#10;&#10;public class ErrorRecord {&#10;}&#10;" />
              <option name="updatedContent" value="package nl.hva.ewa.regenwormen.domain.errorForm;&#10;&#10;import nl.hva.ewa.regenwormen.domain.Enum.ErrorStatus;&#10;import nl.hva.ewa.regenwormen.domain.Enum.GameState;&#10;&#10;public record ErrorRecord(&#10;    String name,&#10;    String topic,&#10;    String category,&#10;    String priority,&#10;    String details,&#10;    GameState gameState,&#10;    String userId,&#10;    String gameId&#10;) {&#10;    // Record class voor eenvoudige error report data&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/frontend/src/components/Game/GameMain.vue">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/frontend/src/components/Game/GameMain.vue" />
              <option name="originalContent" value="&lt;template&gt;&#10;  &lt;div class=&quot;game&quot;&gt;&#10;    &lt;h1&gt; Regenwormen&lt;/h1&gt;&#10;&#10;    &lt;div v-if=&quot;!gameReady&quot;&gt;&#10;      &lt;p&gt;⏳ Joining game...&lt;/p&gt;&#10;      &lt;p v-if=&quot;errorMsg&quot; class=&quot;err&quot;&gt;{{ errorMsg }}&lt;/p&gt;&#10;    &lt;/div&gt;&#10;&#10;    &lt;div v-else&gt;&#10;      &lt;button class=&quot;back-button&quot; @click=&quot;goToLobby&quot;&gt;⬅️ Terug naar Lobby&lt;/button&gt;&#10;&#10;      &lt;h3&gt;Game ID: {{ gameId }}&lt;/h3&gt;&#10;      &lt;h4&gt;Jij: {{ username }}&lt;/h4&gt;&#10;&#10;      &lt;!--  System messages --&gt;&#10;      &lt;div v-if=&quot;gameMessage&quot; class=&quot;system-msg&quot;&gt;&#10;        {{ gameMessage }}&#10;      &lt;/div&gt;&#10;&#10;      &lt;!--  Turn timer box (always visible) --&gt;&#10;      &lt;div class=&quot;timer-box&quot; v-if=&quot;timeLeft &gt; 0 || currentTimerPlayer&quot;&gt;&#10;        &lt;p v-if=&quot;currentTimerPlayer === username&quot;&gt;&#10;          ⏳ Jouw beurt: &lt;strong&gt;{{ timeLeft }}s&lt;/strong&gt; over&#10;        &lt;/p&gt;&#10;        &lt;p v-else&gt;&#10;           {{ currentTimerPlayer }} is aan de beurt ({{ timeLeft }}s)&#10;        &lt;/p&gt;&#10;      &lt;/div&gt;&#10;&#10;      &lt;p v-if=&quot;turnInfo&quot; class=&quot;turn&quot;&gt;Beurt: {{ turnInfo }}&lt;/p&gt;&#10;&#10;      &lt;!--  Points counter --&gt;&#10;      &lt;p v-if=&quot;hasStartedRoll&quot; class=&quot;points&quot;&gt;&#10;         Points this round: &lt;strong&gt;{{ roundPoints }}&lt;/strong&gt;&#10;      &lt;/p&gt;&#10;&#10;      &lt;!--  Roll button --&gt;&#10;      &lt;button&#10;          v-if=&quot;currentPlayerId === username &amp;&amp; !isBusted&quot;&#10;          class=&quot;roll-btn&quot;&#10;          @click=&quot;rollDice&quot;&#10;          :disabled=&quot;rolling || (timeLeft &lt;= 0 &amp;&amp; currentPlayerId !== username)&quot;&#10;      &gt;&#10;        {{ hasStartedRoll ? &quot;Roll Again&quot; : &quot; Roll Dice&quot; }}&#10;      &lt;/button&gt;&#10;&#10;      &lt;!--  Dice area --&gt;&#10;      &lt;div class=&quot;dice-area&quot; v-if=&quot;rolledDice.length&quot;&gt;&#10;        &lt;div&#10;            v-for=&quot;(face, idx) in rolledDice&quot;&#10;            :key=&quot;idx&quot;&#10;            :class=&quot;[&#10;            'die',&#10;            { disabled: disabledFaces.includes(face), chosen: chosenFaces.includes(face) }&#10;          ]&quot;&#10;            @click=&quot;trySelectDie(face)&quot;&#10;        &gt;&#10;          {{ faceEmoji(face) }}&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;&#10;      &lt;!--  Collected dice summary --&gt;&#10;      &lt;DiceCollected :collectedDice=&quot;collectedDice&quot; /&gt;&#10;&#10;      &lt;!--  Tiles to claim --&gt;&#10;      &lt;div class=&quot;tiles-table&quot;&gt;&#10;        &lt;div&#10;            v-for=&quot;tile in tilesOnTable&quot;&#10;            :key=&quot;tile.value&quot;&#10;            :class=&quot;['tile', { disabled: !canClaim(tile) }]&quot;&#10;            @click=&quot;tryPickTile(tile)&quot;&#10;        &gt;&#10;          &lt;span&gt;{{ tile.value }}&lt;/span&gt;&#10;          &lt;span class=&quot;worms&quot;&gt; x{{ tile.points || 1 }}&lt;/span&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;&#10;      &lt;!--  &amp;  Players section --&gt;&#10;      &lt;div class=&quot;game-board&quot;&gt;&#10;        &lt;!--  My tiles &amp; score --&gt;&#10;        &lt;div class=&quot;my-section&quot;&gt;&#10;          &lt;h3&gt;Mijn Tegels&lt;/h3&gt;&#10;          &lt;div class=&quot;my-tiles-list&quot;&gt;&#10;            &lt;div v-for=&quot;t in myTiles&quot; :key=&quot;t.value&quot; class=&quot;my-tile&quot;&gt;&#10;              {{ t.value }} &lt;small&gt; x{{ t.points }}&lt;/small&gt;&#10;            &lt;/div&gt;&#10;          &lt;/div&gt;&#10;          &lt;p class=&quot;my-score&quot;&gt;Totale punten: &lt;strong&gt;{{ myTilesScore }}&lt;/strong&gt;&lt;/p&gt;&#10;        &lt;/div&gt;&#10;&#10;        &lt;!--  Other players --&gt;&#10;        &lt;div class=&quot;others-section&quot;&gt;&#10;          &lt;div&#10;              v-for=&quot;p in players.filter(pl =&gt; pl.name !== username)&quot;&#10;              :key=&quot;p?.id || p?.name&quot;&#10;              class=&quot;other-player&quot;&#10;          &gt;&#10;            &lt;h4&gt;{{ p.name || 'Unknown' }}&lt;/h4&gt;&#10;            &lt;p&gt;Total Tile Points: &lt;strong&gt;{{ p.points ?? playerScore(p) }}&lt;/strong&gt;&lt;/p&gt;&#10;            &lt;TilesOtherPlayer :tiles=&quot;p.tiles || []&quot; :topTile=&quot;p.topTile&quot; /&gt;&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;      &lt;button class=&quot;error-button&quot; @click=&quot;showErrorForm = true&quot;&gt;❗&lt;/button&gt;&#10;      &lt;ErrorHandelingForm :visible=&quot;showErrorForm&quot; @close=&quot;showErrorForm = false&quot; @open=&quot;showErrorForm = true&quot; /&gt;&#10;&#10;      &lt;button class=&quot;help-button&quot; @click=&quot;showRules = true&quot;&gt;❓&lt;/button&gt;&#10;      &lt;HowToPlayButton :visible=&quot;showRules&quot; @close=&quot;showRules = false&quot; /&gt;&#10;    &lt;/div&gt;&#10;  &lt;/div&gt;&#10;&lt;/template&gt;&#10;&#10;&lt;script setup&gt;&#10;import { ref, computed, onMounted, onUnmounted } from &quot;vue&quot;&#10;import { useRouter } from &quot;vue-router&quot;&#10;import DiceCollected from &quot;./DiceCollected.vue&quot;&#10;import TilesCollected from &quot;./TilesCollected.vue&quot;&#10;import ErrorHandelingForm from &quot;@/components/Game/game_assistance/ErrorHandelingForm.vue&quot;;&#10;import TilesOtherPlayer from &quot;./TilesOtherPlayer.vue&quot;&#10;import HowToPlayButton from &quot;./game_assistance/HowToPlayButton.vue&quot;&#10;import SockJS from &quot;sockjs-client&quot;&#10;import { Client } from &quot;@stomp/stompjs&quot;&#10;&#10;const router = useRouter()&#10;&#10;// ---  API + STOMP/SockJS ---&#10;const API_INGAME = &quot;http://localhost:8080/ingame&quot;&#10;const SOCKJS_URL = &quot;http://localhost:8080/ws&quot;&#10;&#10;let stompClient = null&#10;&#10;// --- USER / GAME STATE ---&#10;const user = JSON.parse(localStorage.getItem(&quot;user&quot;))&#10;const username = user?.username || user?.name || &quot;Guest&quot;&#10;const gameId = ref(localStorage.getItem(&quot;gameId&quot;) || null)&#10;const gameReady = ref(!!gameId.value)&#10;const errorMsg = ref(&quot;&quot;)&#10;const showRules = ref(false)&#10;const showErrorForm = ref(false)&#10;const rolling = ref(false)&#10;&#10;// --- GAME DATA ---&#10;const rolledDice = ref([])&#10;const disabledFaces = ref([])&#10;const chosenFaces = ref([])&#10;const collectedDice = ref([])&#10;const tilesOnTable = ref([])&#10;const players = ref([])&#10;const currentPlayerId = ref(null)&#10;const currentTurnIndex = ref(null)&#10;const hasStartedRoll = ref(false)&#10;const busted = ref(false)&#10;const roundPoints = ref(0)&#10;const myTiles = ref([])&#10;&#10;// --- ⏳ TIMER &amp; MESSAGE STATE ---&#10;const timeLeft = ref(0)&#10;const currentTimerPlayer = ref(&quot;&quot;)&#10;const gameMessage = ref(&quot;&quot;) //  from backend (/message)&#10;&#10;// --- COMPUTED ---&#10;const turnInfo = computed(() =&gt; {&#10;  if (!players.value?.length || currentTurnIndex.value == null) return &quot;&quot;&#10;  const p = players.value[currentTurnIndex.value]&#10;  return p ? `${p.name ?? p.id}` : &quot;&quot;&#10;})&#10;const isBusted = computed(() =&gt; busted.value)&#10;&#10;const myTilesScore = computed(() =&gt;&#10;    myTiles.value.reduce((sum, t) =&gt; sum + (t.points || 0), 0)&#10;)&#10;&#10;function playerScore(player) {&#10;  if (!player || !player.tiles || !Array.isArray(player.tiles)) return 0&#10;  return player.tiles.reduce((sum, t) =&gt; sum + (t.points || 0), 0)&#10;}&#10;&#10;// === FETCH HELPERS ===&#10;async function post(url, body = null) {&#10;  const res = await fetch(url, {&#10;    method: &quot;POST&quot;,&#10;    headers: { &quot;Content-Type&quot;: &quot;application/json&quot; },&#10;    body: body ? JSON.stringify(body) : null,&#10;  })&#10;  if (!res.ok) {&#10;    const t = await res.text().catch(() =&gt; &quot;&quot;)&#10;    throw new Error(`Backend error ${res.status}: ${t}`)&#10;  }&#10;  const type = res.headers.get(&quot;content-type&quot;) || &quot;&quot;&#10;  return type.includes(&quot;application/json&quot;) ? res.json() : null&#10;}&#10;&#10;// ===  Apply game snapshot from WS ===&#10;function applyGame(game) {&#10;  if (!game) return&#10;&#10;  const previousPlayer = currentPlayerId.value&#10;&#10;  players.value = game.players || []&#10;  tilesOnTable.value = game.tilesPot?.tiles || []&#10;  currentTurnIndex.value = game.turnIndex ?? null&#10;  currentPlayerId.value = players.value?.[game.turnIndex]?.name || null&#10;&#10;  //  If it's a new round and now your turn — reset your UI&#10;  if (currentPlayerId.value !== previousPlayer &amp;&amp; currentPlayerId.value === username) {&#10;    resetRound()&#10;    busted.value = false&#10;    gameMessage.value = &quot; It's your turn!&quot;&#10;  }&#10;&#10;  // Sync my tiles from snapshot&#10;  const me = players.value.find(p =&gt; p.name === username || p.id === username)&#10;  myTiles.value = Array.isArray(me?.tiles) ? me.tiles : myTiles.value&#10;}&#10;&#10;&#10;// ===  STOMP/SockJS SETUP ===&#10;function connectStomp() {&#10;  const sock = new SockJS(SOCKJS_URL)&#10;  stompClient = new Client({&#10;    debug: () =&gt; {},&#10;    reconnectDelay: 500,&#10;    webSocketFactory: () =&gt; sock,&#10;  })&#10;&#10;  stompClient.onConnect = () =&gt; {&#10;    // --- Game state updates ---&#10;    stompClient.subscribe(`/topic/game/${gameId.value}`, (msg) =&gt; {&#10;      try {&#10;        const game = JSON.parse(msg.body)&#10;        applyGame(game)&#10;        gameReady.value = true&#10;      } catch (e) {&#10;        console.warn(&quot;Failed parsing game snapshot:&quot;, e)&#10;      }&#10;    })&#10;&#10;    // --- Timer updates ---&#10;    stompClient.subscribe(`/topic/game/${gameId.value}/timer`, (msg) =&gt; {&#10;      try {&#10;        const data = JSON.parse(msg.body)&#10;        currentTimerPlayer.value = data.player&#10;        timeLeft.value = data.timeLeft&#10;      } catch (e) {}&#10;    })&#10;&#10;    // --- Turn timeout ---&#10;    stompClient.subscribe(`/topic/game/${gameId.value}/turnTimeout`, (msg) =&gt; {&#10;      try {&#10;        const data = JSON.parse(msg.body)&#10;&#10;        // Always stop local timer&#10;        timeLeft.value = 0&#10;&#10;        //  Notify all players&#10;        if (data.player === username) {&#10;          gameMessage.value = &quot;⏰ Your turn expired! You lost this round.&quot;&#10;        } else {&#10;          gameMessage.value = `⚠️ ${data.player}'s turn expired!`&#10;        }&#10;&#10;        //  Reset the local round state if backend requests it&#10;        if (data.reset) {&#10;          resetRound()&#10;          busted.value = true&#10;        }&#10;&#10;        // Clear message after 5 seconds&#10;        setTimeout(() =&gt; (gameMessage.value = &quot;&quot;), 5000)&#10;      } catch (e) {&#10;        console.warn(&quot;Failed to process turn timeout:&quot;, e)&#10;      }&#10;    })&#10;&#10;&#10;    // ---  System messages ---&#10;    stompClient.subscribe(`/topic/game/${gameId.value}/message`, (msg) =&gt; {&#10;      try {&#10;        const data = JSON.parse(msg.body)&#10;        gameMessage.value = data.text&#10;        setTimeout(() =&gt; (gameMessage.value = &quot;&quot;), 5000)&#10;      } catch (e) {&#10;        console.warn(&quot;Invalid system message:&quot;, e)&#10;      }&#10;    })&#10;&#10;&#10;    // Request initial state&#10;    stompClient.publish({ destination: &quot;/app/timerSync&quot;, body: gameId.value })&#10;    stompClient.publish({ destination: &quot;/app/sync&quot;, body: gameId.value })&#10;  }&#10;&#10;  stompClient.onStompError = (frame) =&gt; {&#10;    console.error(&quot;Broker error:&quot;, frame.headers[&quot;message&quot;])&#10;    errorMsg.value = &quot;WebSocket broker error.&quot;&#10;  }&#10;&#10;  stompClient.onWebSocketError = (e) =&gt; {&#10;    console.error(&quot;WebSocket error:&quot;, e)&#10;    errorMsg.value = &quot;WebSocket connection failed.&quot;&#10;  }&#10;&#10;  stompClient.activate()&#10;}&#10;&#10;// === LIFECYCLE ===&#10;onMounted(() =&gt; {&#10;  if (!gameId.value) {&#10;    errorMsg.value = &quot;No active game found — start one from lobby.&quot;&#10;    return&#10;  }&#10;  connectStomp()&#10;})&#10;onUnmounted(() =&gt; {&#10;  if (stompClient) stompClient.deactivate()&#10;})&#10;&#10;// ===  GAME ACTIONS ===&#10;async function rollDice() {&#10;  rolling.value = true&#10;  try {&#10;    const endpoint = hasStartedRoll.value ? &quot;reroll&quot; : &quot;startroll&quot;&#10;    const data = await post(`${API_INGAME}/${gameId.value}/${endpoint}/${username}`)&#10;    if (!data || data.fullThrow == null) {&#10;      gameMessage.value = &quot; You busted! Your turn is over.&quot;&#10;      busted.value = true&#10;      resetRound()&#10;      return&#10;    }&#10;    rolledDice.value = Object.entries(data.fullThrow).flatMap(([face, count]) =&gt;&#10;        Array(count).fill(face)&#10;    )&#10;    disabledFaces.value = data.disabledFaces || []&#10;    chosenFaces.value = Array.from(data.chosenFaces || [])&#10;    hasStartedRoll.value = true&#10;  } catch {&#10;    gameMessage.value = &quot;Something went wrong while rolling dice.&quot;&#10;  } finally {&#10;    rolling.value = false&#10;  }&#10;}&#10;&#10;async function trySelectDie(face) {&#10;  if (disabledFaces.value.includes(face) || chosenFaces.value.includes(face)) return&#10;  try {&#10;    const data = await post(`${API_INGAME}/${gameId.value}/pickdice/${username}`, face)&#10;    if (!data || data.fullThrow == null) {&#10;      gameMessage.value = &quot; You busted after this pick! Turn over.&quot;&#10;      busted.value = true&#10;      resetRound()&#10;      return&#10;    }&#10;    const pickedCount = rolledDice.value.filter(f =&gt; f === face).length&#10;    for (let i = 0; i &lt; pickedCount; i++) collectedDice.value.push(face)&#10;    updateRoundPoints()&#10;    rolledDice.value = Object.entries(data.fullThrow || {}).flatMap(([f, count]) =&gt;&#10;        Array(count).fill(f)&#10;    )&#10;    disabledFaces.value = data.disabledFaces || []&#10;    chosenFaces.value = Array.from(data.chosenFaces || [])&#10;  } catch {&#10;    gameMessage.value = &quot;Failed to select dice face.&quot;&#10;  }&#10;}&#10;&#10;// ===  TILE LOGIC ===&#10;function canClaim(tile) {&#10;  return roundPoints.value &gt;= tile.value&#10;}&#10;async function tryPickTile(tile) {&#10;  if (!canClaim(tile)) return&#10;  await pickTile(tile)&#10;}&#10;async function pickTile(tile) {&#10;  try {&#10;    await post(`${API_INGAME}/${gameId.value}/claimfrompot/${username}`)&#10;    resetRound()&#10;    busted.value = false&#10;  } catch {&#10;    gameMessage.value = &quot;Failed to claim tile.&quot;&#10;  }&#10;}&#10;&#10;// === HELPERS ===&#10;function updateRoundPoints() {&#10;  const faceValue = { ONE: 1, TWO: 2, THREE: 3, FOUR: 4, FIVE: 5, SPECIAL: 5 }&#10;  const counts = collectedDice.value.reduce((acc, f) =&gt; {&#10;    acc[f] = (acc[f] || 0) + 1&#10;    return acc&#10;  }, {})&#10;  roundPoints.value = Object.entries(counts)&#10;      .reduce((total, [face, count]) =&gt; total + (faceValue[face] || 0) * count, 0)&#10;}&#10;function resetRound() {&#10;  rolledDice.value = []&#10;  collectedDice.value = []&#10;  disabledFaces.value = []&#10;  chosenFaces.value = []&#10;  hasStartedRoll.value = false&#10;  roundPoints.value = 0&#10;}&#10;function faceEmoji(face) {&#10;  const map = { ONE: &quot;1️⃣&quot;, TWO: &quot;2️⃣&quot;, THREE: &quot;3️⃣&quot;, FOUR: &quot;4️⃣&quot;, FIVE: &quot;5️⃣&quot;, SPECIAL: &quot;&quot; }&#10;  return map[face] || face&#10;}&#10;&#10;function goToLobby() {&#10;  router.push(&quot;/lobbies&quot;)&#10;}&#10;&lt;/script&gt;&#10;&#10;&lt;style scoped&gt;&#10;.game {&#10;  background: #fafafa;&#10;  color: #111;&#10;  min-height: 100vh;&#10;  padding: 2rem;&#10;  text-align: center;&#10;  font-family: &quot;Inter&quot;, sans-serif;&#10;}&#10;h1, h3, h4, p { color: #111; }&#10;.points {&#10;  margin: 0.5rem 0 1rem;&#10;  font-weight: 700;&#10;  color: #2c7a2c;&#10;  font-size: 1.2rem;&#10;}&#10;&#10;.timer-box {&#10;  margin: 1rem 0;&#10;  font-weight: bold;&#10;  color: #e63946;&#10;  background: #fff3cd;&#10;  border-radius: 8px;&#10;  padding: .5rem 1rem;&#10;  display: inline-block;&#10;  transition: all 0.4s ease;&#10;}&#10;&#10;.roll-btn {&#10;  background: #4caf50;&#10;  color: white;&#10;  border: none;&#10;  padding: 12px 25px;&#10;  font-size: 1.2rem;&#10;  border-radius: 10px;&#10;  cursor: pointer;&#10;  margin-top: 1rem;&#10;}&#10;.roll-btn:hover { background: #43a047; transform: scale(1.05); }&#10;.roll-btn:disabled { background: #aaa; cursor: not-allowed; }&#10;&#10;.back-button {&#10;  position: fixed;&#10;  bottom: 20px;&#10;  left: 20px;&#10;  background: #eee;&#10;  border: none;&#10;  padding: 10px 16px;&#10;  border-radius: 8px;&#10;  cursor: pointer;&#10;  font-size: 16px;&#10;  box-shadow: 0 4px 10px rgba(0,0,0,0.25);&#10;}&#10;.back-button:hover { background: #ddd; }&#10;&#10;&#10;.dice-area {&#10;  display: flex;&#10;  justify-content: center;&#10;  flex-wrap: wrap;&#10;  gap: 1rem;&#10;  margin: 1.5rem 0;&#10;}&#10;.die {&#10;  font-size: 2.2rem;&#10;  width: 55px;&#10;  height: 55px;&#10;  border-radius: 12px;&#10;  display: flex;&#10;  align-items: center;&#10;  justify-content: center;&#10;  background: #fff;&#10;  box-shadow: 0 2px 5px rgba(0,0,0,0.2);&#10;  cursor: pointer;&#10;  transition: all 0.2s ease;&#10;}&#10;.die.disabled { opacity: 0.4; cursor: not-allowed; background: #ddd; }&#10;.die.chosen { background: #e3f8d3; border: 2px solid #4caf50; }&#10;&#10;.tiles-table {&#10;  display: flex;&#10;  justify-content: center;&#10;  flex-wrap: wrap;&#10;  gap: 0.8rem;&#10;  margin-top: 1rem;&#10;}&#10;.tile {&#10;  background: #fff;&#10;  border: 2px solid #4caf50;&#10;  border-radius: 10px;&#10;  padding: 10px 15px;&#10;  cursor: pointer;&#10;  font-weight: bold;&#10;  transition: all 0.2s ease;&#10;}&#10;.tile:hover { background: #e8f5e9; transform: scale(1.05); }&#10;.tile.disabled {&#10;  border-color: #aaa;&#10;  background: #f3f3f3;&#10;  color: #999;&#10;  cursor: not-allowed;&#10;  transform: none;&#10;}&#10;.worms { display: block; font-size: 0.8rem; color: #555; }&#10;&#10;.game-board { display: flex; justify-content: space-between; margin-top: 2rem; gap: 2rem; flex-wrap: wrap; }&#10;.my-section, .others-section { flex: 1; min-width: 200px; }&#10;.my-tiles-list {&#10;  display: flex;&#10;  justify-content: center;&#10;  gap: 0.5rem;&#10;  flex-wrap: wrap;&#10;}&#10;.my-tile {&#10;  background: #fefefe;&#10;  border: 2px solid #2196f3;&#10;  border-radius: 8px;&#10;  padding: 6px 12px;&#10;  font-weight: 600;&#10;  box-shadow: 0 2px 4px rgba(0,0,0,0.15);&#10;}&#10;.my-tile small { font-size: 0.8rem; margin-left: 4px; color: #444; }&#10;.my-score { font-weight: 700; color: #1565c0; margin-top: 0.5rem; }&#10;&#10;.other-player {&#10;  margin-bottom: 1.5rem; border: 1px solid #ddd; border-radius: 8px; padding: 10px; background: #fff;&#10;}&#10;.help-button, .error-button{&#10;  position: fixed;&#10;  bottom: 20px;&#10;  right: 20px;&#10;  background: #eee;&#10;  border: none;&#10;  border-radius: 50%;&#10;  width: 45px;&#10;  height: 45px;&#10;  font-size: 22px;&#10;  cursor: pointer;&#10;  color: #333;&#10;  box-shadow: 0 4px 10px rgba(0,0,0,0.25);&#10;}&#10;&#10;.error-button{&#10;  right: 70px;&#10;}&#10;.help-button:hover, .error-button:hover { background: #ddd; transform: scale(1.05); }&#10;&#10;&#10;.err { color: #b00020; margin-top: .5rem; font-weight: 600; }&#10;.turn { margin: .25rem 0 1rem; font-weight: 600; color: #333; }&#10;&lt;/style&gt;&#10;" />
              <option name="updatedContent" value="&lt;template&gt;&#10;  &lt;div class=&quot;game&quot;&gt;&#10;    &lt;h1&gt; Regenwormen&lt;/h1&gt;&#10;&#10;    &lt;div v-if=&quot;!gameReady&quot;&gt;&#10;      &lt;p&gt;⏳ Joining game...&lt;/p&gt;&#10;      &lt;p v-if=&quot;errorMsg&quot; class=&quot;err&quot;&gt;{{ errorMsg }}&lt;/p&gt;&#10;    &lt;/div&gt;&#10;&#10;    &lt;div v-else&gt;&#10;      &lt;button class=&quot;back-button&quot; @click=&quot;goToLobby&quot;&gt;⬅️ Terug naar Lobby&lt;/button&gt;&#10;&#10;      &lt;h3&gt;Game ID: {{ gameId }}&lt;/h3&gt;&#10;      &lt;h4&gt;Jij: {{ username }}&lt;/h4&gt;&#10;&#10;      &lt;!--  System messages --&gt;&#10;      &lt;div v-if=&quot;gameMessage&quot; class=&quot;system-msg&quot;&gt;&#10;        {{ gameMessage }}&#10;      &lt;/div&gt;&#10;&#10;      &lt;!--  Turn timer box (always visible) --&gt;&#10;      &lt;div class=&quot;timer-box&quot; v-if=&quot;timeLeft &gt; 0 || currentTimerPlayer&quot;&gt;&#10;        &lt;p v-if=&quot;currentTimerPlayer === username&quot;&gt;&#10;          ⏳ Jouw beurt: &lt;strong&gt;{{ timeLeft }}s&lt;/strong&gt; over&#10;        &lt;/p&gt;&#10;        &lt;p v-else&gt;&#10;           {{ currentTimerPlayer }} is aan de beurt ({{ timeLeft }}s)&#10;        &lt;/p&gt;&#10;      &lt;/div&gt;&#10;&#10;      &lt;p v-if=&quot;turnInfo&quot; class=&quot;turn&quot;&gt;Beurt: {{ turnInfo }}&lt;/p&gt;&#10;&#10;      &lt;!--  Points counter --&gt;&#10;      &lt;p v-if=&quot;hasStartedRoll&quot; class=&quot;points&quot;&gt;&#10;         Points this round: &lt;strong&gt;{{ roundPoints }}&lt;/strong&gt;&#10;      &lt;/p&gt;&#10;&#10;      &lt;!--  Roll button --&gt;&#10;      &lt;button&#10;          v-if=&quot;currentPlayerId === username &amp;&amp; !isBusted&quot;&#10;          class=&quot;roll-btn&quot;&#10;          @click=&quot;rollDice&quot;&#10;          :disabled=&quot;rolling || (timeLeft &lt;= 0 &amp;&amp; currentPlayerId !== username)&quot;&#10;      &gt;&#10;        {{ hasStartedRoll ? &quot;Roll Again&quot; : &quot; Roll Dice&quot; }}&#10;      &lt;/button&gt;&#10;&#10;      &lt;!--  Dice area --&gt;&#10;      &lt;div class=&quot;dice-area&quot; v-if=&quot;rolledDice.length&quot;&gt;&#10;        &lt;div&#10;            v-for=&quot;(face, idx) in rolledDice&quot;&#10;            :key=&quot;idx&quot;&#10;            :class=&quot;[&#10;            'die',&#10;            { disabled: disabledFaces.includes(face), chosen: chosenFaces.includes(face) }&#10;          ]&quot;&#10;            @click=&quot;trySelectDie(face)&quot;&#10;        &gt;&#10;          {{ faceEmoji(face) }}&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;&#10;      &lt;!--  Collected dice summary --&gt;&#10;      &lt;DiceCollected :collectedDice=&quot;collectedDice&quot; /&gt;&#10;&#10;      &lt;!--  Tiles to claim --&gt;&#10;      &lt;div class=&quot;tiles-table&quot;&gt;&#10;        &lt;div&#10;            v-for=&quot;tile in tilesOnTable&quot;&#10;            :key=&quot;tile.value&quot;&#10;            :class=&quot;['tile', { disabled: !canClaim(tile) }]&quot;&#10;            @click=&quot;tryPickTile(tile)&quot;&#10;        &gt;&#10;          &lt;span&gt;{{ tile.value }}&lt;/span&gt;&#10;          &lt;span class=&quot;worms&quot;&gt; x{{ tile.points || 1 }}&lt;/span&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;&#10;      &lt;!--  &amp;  Players section --&gt;&#10;      &lt;div class=&quot;game-board&quot;&gt;&#10;        &lt;!--  My tiles &amp; score --&gt;&#10;        &lt;div class=&quot;my-section&quot;&gt;&#10;          &lt;h3&gt;Mijn Tegels&lt;/h3&gt;&#10;          &lt;div class=&quot;my-tiles-list&quot;&gt;&#10;            &lt;div v-for=&quot;t in myTiles&quot; :key=&quot;t.value&quot; class=&quot;my-tile&quot;&gt;&#10;              {{ t.value }} &lt;small&gt; x{{ t.points }}&lt;/small&gt;&#10;            &lt;/div&gt;&#10;          &lt;/div&gt;&#10;          &lt;p class=&quot;my-score&quot;&gt;Totale punten: &lt;strong&gt;{{ myTilesScore }}&lt;/strong&gt;&lt;/p&gt;&#10;        &lt;/div&gt;&#10;&#10;        &lt;!--  Other players --&gt;&#10;        &lt;div class=&quot;others-section&quot;&gt;&#10;          &lt;div&#10;              v-for=&quot;p in players.filter(pl =&gt; pl.name !== username)&quot;&#10;              :key=&quot;p?.id || p?.name&quot;&#10;              class=&quot;other-player&quot;&#10;          &gt;&#10;            &lt;h4&gt;{{ p.name || 'Unknown' }}&lt;/h4&gt;&#10;            &lt;p&gt;Total Tile Points: &lt;strong&gt;{{ p.points ?? playerScore(p) }}&lt;/strong&gt;&lt;/p&gt;&#10;            &lt;TilesOtherPlayer :tiles=&quot;p.tiles || []&quot; :topTile=&quot;p.topTile&quot; /&gt;&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;      &lt;button class=&quot;error-button&quot; @click=&quot;showErrorForm = true&quot;&gt;❗&lt;/button&gt;&#10;      &lt;ErrorHandelingForm &#10;        :visible=&quot;showErrorForm&quot; &#10;        :gameState=&quot;getCurrentGameState()&quot;&#10;        @close=&quot;showErrorForm = false&quot; &#10;        @open=&quot;showErrorForm = true&quot; &#10;      /&gt;&#10;&#10;      &lt;button class=&quot;help-button&quot; @click=&quot;showRules = true&quot;&gt;❓&lt;/button&gt;&#10;      &lt;HowToPlayButton :visible=&quot;showRules&quot; @close=&quot;showRules = false&quot; /&gt;&#10;    &lt;/div&gt;&#10;  &lt;/div&gt;&#10;&lt;/template&gt;&#10;&#10;&lt;script setup&gt;&#10;import { ref, computed, onMounted, onUnmounted } from &quot;vue&quot;&#10;import { useRouter } from &quot;vue-router&quot;&#10;import DiceCollected from &quot;./DiceCollected.vue&quot;&#10;import TilesCollected from &quot;./TilesCollected.vue&quot;&#10;import ErrorHandelingForm from &quot;@/components/Game/game_assistance/ErrorHandelingForm.vue&quot;;&#10;import TilesOtherPlayer from &quot;./TilesOtherPlayer.vue&quot;&#10;import HowToPlayButton from &quot;./game_assistance/HowToPlayButton.vue&quot;&#10;import SockJS from &quot;sockjs-client&quot;&#10;import { Client } from &quot;@stomp/stompjs&quot;&#10;&#10;const router = useRouter()&#10;&#10;// ---  API + STOMP/SockJS ---&#10;const API_INGAME = &quot;http://localhost:8080/ingame&quot;&#10;const SOCKJS_URL = &quot;http://localhost:8080/ws&quot;&#10;&#10;let stompClient = null&#10;&#10;// --- USER / GAME STATE ---&#10;const user = JSON.parse(localStorage.getItem(&quot;user&quot;))&#10;const username = user?.username || user?.name || &quot;Guest&quot;&#10;const gameId = ref(localStorage.getItem(&quot;gameId&quot;) || null)&#10;const gameReady = ref(!!gameId.value)&#10;const errorMsg = ref(&quot;&quot;)&#10;const showRules = ref(false)&#10;const showErrorForm = ref(false)&#10;const rolling = ref(false)&#10;&#10;// --- GAME DATA ---&#10;const rolledDice = ref([])&#10;const disabledFaces = ref([])&#10;const chosenFaces = ref([])&#10;const collectedDice = ref([])&#10;const tilesOnTable = ref([])&#10;const players = ref([])&#10;const currentPlayerId = ref(null)&#10;const currentTurnIndex = ref(null)&#10;const hasStartedRoll = ref(false)&#10;const busted = ref(false)&#10;const roundPoints = ref(0)&#10;const myTiles = ref([])&#10;&#10;// --- ⏳ TIMER &amp; MESSAGE STATE ---&#10;const timeLeft = ref(0)&#10;const currentTimerPlayer = ref(&quot;&quot;)&#10;const gameMessage = ref(&quot;&quot;) //  from backend (/message)&#10;&#10;// --- COMPUTED ---&#10;const turnInfo = computed(() =&gt; {&#10;  if (!players.value?.length || currentTurnIndex.value == null) return &quot;&quot;&#10;  const p = players.value[currentTurnIndex.value]&#10;  return p ? `${p.name ?? p.id}` : &quot;&quot;&#10;})&#10;const isBusted = computed(() =&gt; busted.value)&#10;&#10;const myTilesScore = computed(() =&gt;&#10;    myTiles.value.reduce((sum, t) =&gt; sum + (t.points || 0), 0)&#10;)&#10;&#10;function playerScore(player) {&#10;  if (!player || !player.tiles || !Array.isArray(player.tiles)) return 0&#10;  return player.tiles.reduce((sum, t) =&gt; sum + (t.points || 0), 0)&#10;}&#10;&#10;// === FETCH HELPERS ===&#10;async function post(url, body = null) {&#10;  const res = await fetch(url, {&#10;    method: &quot;POST&quot;,&#10;    headers: { &quot;Content-Type&quot;: &quot;application/json&quot; },&#10;    body: body ? JSON.stringify(body) : null,&#10;  })&#10;  if (!res.ok) {&#10;    const t = await res.text().catch(() =&gt; &quot;&quot;)&#10;    throw new Error(`Backend error ${res.status}: ${t}`)&#10;  }&#10;  const type = res.headers.get(&quot;content-type&quot;) || &quot;&quot;&#10;  return type.includes(&quot;application/json&quot;) ? res.json() : null&#10;}&#10;&#10;// ===  Apply game snapshot from WS ===&#10;function applyGame(game) {&#10;  if (!game) return&#10;&#10;  const previousPlayer = currentPlayerId.value&#10;&#10;  players.value = game.players || []&#10;  tilesOnTable.value = game.tilesPot?.tiles || []&#10;  currentTurnIndex.value = game.turnIndex ?? null&#10;  currentPlayerId.value = players.value?.[game.turnIndex]?.name || null&#10;&#10;  //  If it's a new round and now your turn — reset your UI&#10;  if (currentPlayerId.value !== previousPlayer &amp;&amp; currentPlayerId.value === username) {&#10;    resetRound()&#10;    busted.value = false&#10;    gameMessage.value = &quot; It's your turn!&quot;&#10;  }&#10;&#10;  // Sync my tiles from snapshot&#10;  const me = players.value.find(p =&gt; p.name === username || p.id === username)&#10;  myTiles.value = Array.isArray(me?.tiles) ? me.tiles : myTiles.value&#10;}&#10;&#10;&#10;// ===  STOMP/SockJS SETUP ===&#10;function connectStomp() {&#10;  const sock = new SockJS(SOCKJS_URL)&#10;  stompClient = new Client({&#10;    debug: () =&gt; {},&#10;    reconnectDelay: 500,&#10;    webSocketFactory: () =&gt; sock,&#10;  })&#10;&#10;  stompClient.onConnect = () =&gt; {&#10;    // --- Game state updates ---&#10;    stompClient.subscribe(`/topic/game/${gameId.value}`, (msg) =&gt; {&#10;      try {&#10;        const game = JSON.parse(msg.body)&#10;        applyGame(game)&#10;        gameReady.value = true&#10;      } catch (e) {&#10;        console.warn(&quot;Failed parsing game snapshot:&quot;, e)&#10;      }&#10;    })&#10;&#10;    // --- Timer updates ---&#10;    stompClient.subscribe(`/topic/game/${gameId.value}/timer`, (msg) =&gt; {&#10;      try {&#10;        const data = JSON.parse(msg.body)&#10;        currentTimerPlayer.value = data.player&#10;        timeLeft.value = data.timeLeft&#10;      } catch (e) {}&#10;    })&#10;&#10;    // --- Turn timeout ---&#10;    stompClient.subscribe(`/topic/game/${gameId.value}/turnTimeout`, (msg) =&gt; {&#10;      try {&#10;        const data = JSON.parse(msg.body)&#10;&#10;        // Always stop local timer&#10;        timeLeft.value = 0&#10;&#10;        //  Notify all players&#10;        if (data.player === username) {&#10;          gameMessage.value = &quot;⏰ Your turn expired! You lost this round.&quot;&#10;        } else {&#10;          gameMessage.value = `⚠️ ${data.player}'s turn expired!`&#10;        }&#10;&#10;        //  Reset the local round state if backend requests it&#10;        if (data.reset) {&#10;          resetRound()&#10;          busted.value = true&#10;        }&#10;&#10;        // Clear message after 5 seconds&#10;        setTimeout(() =&gt; (gameMessage.value = &quot;&quot;), 5000)&#10;      } catch (e) {&#10;        console.warn(&quot;Failed to process turn timeout:&quot;, e)&#10;      }&#10;    })&#10;&#10;&#10;    // ---  System messages ---&#10;    stompClient.subscribe(`/topic/game/${gameId.value}/message`, (msg) =&gt; {&#10;      try {&#10;        const data = JSON.parse(msg.body)&#10;        gameMessage.value = data.text&#10;        setTimeout(() =&gt; (gameMessage.value = &quot;&quot;), 5000)&#10;      } catch (e) {&#10;        console.warn(&quot;Invalid system message:&quot;, e)&#10;      }&#10;    })&#10;&#10;&#10;    // Request initial state&#10;    stompClient.publish({ destination: &quot;/app/timerSync&quot;, body: gameId.value })&#10;    stompClient.publish({ destination: &quot;/app/sync&quot;, body: gameId.value })&#10;  }&#10;&#10;  stompClient.onStompError = (frame) =&gt; {&#10;    console.error(&quot;Broker error:&quot;, frame.headers[&quot;message&quot;])&#10;    errorMsg.value = &quot;WebSocket broker error.&quot;&#10;  }&#10;&#10;  stompClient.onWebSocketError = (e) =&gt; {&#10;    console.error(&quot;WebSocket error:&quot;, e)&#10;    errorMsg.value = &quot;WebSocket connection failed.&quot;&#10;  }&#10;&#10;  stompClient.activate()&#10;}&#10;&#10;// === LIFECYCLE ===&#10;onMounted(() =&gt; {&#10;  if (!gameId.value) {&#10;    errorMsg.value = &quot;No active game found — start one from lobby.&quot;&#10;    return&#10;  }&#10;  connectStomp()&#10;})&#10;onUnmounted(() =&gt; {&#10;  if (stompClient) stompClient.deactivate()&#10;})&#10;&#10;// ===  GAME ACTIONS ===&#10;async function rollDice() {&#10;  rolling.value = true&#10;  try {&#10;    const endpoint = hasStartedRoll.value ? &quot;reroll&quot; : &quot;startroll&quot;&#10;    const data = await post(`${API_INGAME}/${gameId.value}/${endpoint}/${username}`)&#10;    if (!data || data.fullThrow == null) {&#10;      gameMessage.value = &quot; You busted! Your turn is over.&quot;&#10;      busted.value = true&#10;      resetRound()&#10;      return&#10;    }&#10;    rolledDice.value = Object.entries(data.fullThrow).flatMap(([face, count]) =&gt;&#10;        Array(count).fill(face)&#10;    )&#10;    disabledFaces.value = data.disabledFaces || []&#10;    chosenFaces.value = Array.from(data.chosenFaces || [])&#10;    hasStartedRoll.value = true&#10;  } catch {&#10;    gameMessage.value = &quot;Something went wrong while rolling dice.&quot;&#10;  } finally {&#10;    rolling.value = false&#10;  }&#10;}&#10;&#10;async function trySelectDie(face) {&#10;  if (disabledFaces.value.includes(face) || chosenFaces.value.includes(face)) return&#10;  try {&#10;    const data = await post(`${API_INGAME}/${gameId.value}/pickdice/${username}`, face)&#10;    if (!data || data.fullThrow == null) {&#10;      gameMessage.value = &quot; You busted after this pick! Turn over.&quot;&#10;      busted.value = true&#10;      resetRound()&#10;      return&#10;    }&#10;    const pickedCount = rolledDice.value.filter(f =&gt; f === face).length&#10;    for (let i = 0; i &lt; pickedCount; i++) collectedDice.value.push(face)&#10;    updateRoundPoints()&#10;    rolledDice.value = Object.entries(data.fullThrow || {}).flatMap(([f, count]) =&gt;&#10;        Array(count).fill(f)&#10;    )&#10;    disabledFaces.value = data.disabledFaces || []&#10;    chosenFaces.value = Array.from(data.chosenFaces || [])&#10;  } catch {&#10;    gameMessage.value = &quot;Failed to select dice face.&quot;&#10;  }&#10;}&#10;&#10;// ===  TILE LOGIC ===&#10;function canClaim(tile) {&#10;  return roundPoints.value &gt;= tile.value&#10;}&#10;async function tryPickTile(tile) {&#10;  if (!canClaim(tile)) return&#10;  await pickTile(tile)&#10;}&#10;async function pickTile(tile) {&#10;  try {&#10;    await post(`${API_INGAME}/${gameId.value}/claimfrompot/${username}`)&#10;    resetRound()&#10;    busted.value = false&#10;  } catch {&#10;    gameMessage.value = &quot;Failed to claim tile.&quot;&#10;  }&#10;}&#10;&#10;// === HELPERS ===&#10;function updateRoundPoints() {&#10;  const faceValue = { ONE: 1, TWO: 2, THREE: 3, FOUR: 4, FIVE: 5, SPECIAL: 5 }&#10;  const counts = collectedDice.value.reduce((acc, f) =&gt; {&#10;    acc[f] = (acc[f] || 0) + 1&#10;    return acc&#10;  }, {})&#10;  roundPoints.value = Object.entries(counts)&#10;      .reduce((total, [face, count]) =&gt; total + (faceValue[face] || 0) * count, 0)&#10;}&#10;function resetRound() {&#10;  rolledDice.value = []&#10;  collectedDice.value = []&#10;  disabledFaces.value = []&#10;  chosenFaces.value = []&#10;  hasStartedRoll.value = false&#10;  roundPoints.value = 0&#10;}&#10;function faceEmoji(face) {&#10;  const map = { ONE: &quot;1️⃣&quot;, TWO: &quot;2️⃣&quot;, THREE: &quot;3️⃣&quot;, FOUR: &quot;4️⃣&quot;, FIVE: &quot;5️⃣&quot;, SPECIAL: &quot;&quot; }&#10;  return map[face] || face&#10;}&#10;&#10;function goToLobby() {&#10;  router.push(&quot;/lobbies&quot;)&#10;}&#10;&#10;// ===  GET GAME STATE FOR ERROR REPORT ===&#10;function getCurrentGameState() {&#10;  return {&#10;    gameId: gameId.value,&#10;    currentPlayer: currentPlayerId.value,&#10;    currentTurnIndex: currentTurnIndex.value,&#10;    players: players.value,&#10;    tilesOnTable: tilesOnTable.value,&#10;    rolledDice: rolledDice.value,&#10;    collectedDice: collectedDice.value,&#10;    roundPoints: roundPoints.value,&#10;    myTiles: myTiles.value,&#10;    timeLeft: timeLeft.value,&#10;    hasStartedRoll: hasStartedRoll.value,&#10;    busted: busted.value,&#10;  }&#10;}&#10;&lt;/script&gt;&#10;&#10;&lt;style scoped&gt;&#10;.game {&#10;  background: #fafafa;&#10;  color: #111;&#10;  min-height: 100vh;&#10;  padding: 2rem;&#10;  text-align: center;&#10;  font-family: &quot;Inter&quot;, sans-serif;&#10;}&#10;h1, h3, h4, p { color: #111; }&#10;.points {&#10;  margin: 0.5rem 0 1rem;&#10;  font-weight: 700;&#10;  color: #2c7a2c;&#10;  font-size: 1.2rem;&#10;}&#10;&#10;.timer-box {&#10;  margin: 1rem 0;&#10;  font-weight: bold;&#10;  color: #e63946;&#10;  background: #fff3cd;&#10;  border-radius: 8px;&#10;  padding: .5rem 1rem;&#10;  display: inline-block;&#10;  transition: all 0.4s ease;&#10;}&#10;&#10;.roll-btn {&#10;  background: #4caf50;&#10;  color: white;&#10;  border: none;&#10;  padding: 12px 25px;&#10;  font-size: 1.2rem;&#10;  border-radius: 10px;&#10;  cursor: pointer;&#10;  margin-top: 1rem;&#10;}&#10;.roll-btn:hover { background: #43a047; transform: scale(1.05); }&#10;.roll-btn:disabled { background: #aaa; cursor: not-allowed; }&#10;&#10;.back-button {&#10;  position: fixed;&#10;  bottom: 20px;&#10;  left: 20px;&#10;  background: #eee;&#10;  border: none;&#10;  padding: 10px 16px;&#10;  border-radius: 8px;&#10;  cursor: pointer;&#10;  font-size: 16px;&#10;  box-shadow: 0 4px 10px rgba(0,0,0,0.25);&#10;}&#10;.back-button:hover { background: #ddd; }&#10;&#10;&#10;.dice-area {&#10;  display: flex;&#10;  justify-content: center;&#10;  flex-wrap: wrap;&#10;  gap: 1rem;&#10;  margin: 1.5rem 0;&#10;}&#10;.die {&#10;  font-size: 2.2rem;&#10;  width: 55px;&#10;  height: 55px;&#10;  border-radius: 12px;&#10;  display: flex;&#10;  align-items: center;&#10;  justify-content: center;&#10;  background: #fff;&#10;  box-shadow: 0 2px 5px rgba(0,0,0,0.2);&#10;  cursor: pointer;&#10;  transition: all 0.2s ease;&#10;}&#10;.die.disabled { opacity: 0.4; cursor: not-allowed; background: #ddd; }&#10;.die.chosen { background: #e3f8d3; border: 2px solid #4caf50; }&#10;&#10;.tiles-table {&#10;  display: flex;&#10;  justify-content: center;&#10;  flex-wrap: wrap;&#10;  gap: 0.8rem;&#10;  margin-top: 1rem;&#10;}&#10;.tile {&#10;  background: #fff;&#10;  border: 2px solid #4caf50;&#10;  border-radius: 10px;&#10;  padding: 10px 15px;&#10;  cursor: pointer;&#10;  font-weight: bold;&#10;  transition: all 0.2s ease;&#10;}&#10;.tile:hover { background: #e8f5e9; transform: scale(1.05); }&#10;.tile.disabled {&#10;  border-color: #aaa;&#10;  background: #f3f3f3;&#10;  color: #999;&#10;  cursor: not-allowed;&#10;  transform: none;&#10;}&#10;.worms { display: block; font-size: 0.8rem; color: #555; }&#10;&#10;.game-board { display: flex; justify-content: space-between; margin-top: 2rem; gap: 2rem; flex-wrap: wrap; }&#10;.my-section, .others-section { flex: 1; min-width: 200px; }&#10;.my-tiles-list {&#10;  display: flex;&#10;  justify-content: center;&#10;  gap: 0.5rem;&#10;  flex-wrap: wrap;&#10;}&#10;.my-tile {&#10;  background: #fefefe;&#10;  border: 2px solid #2196f3;&#10;  border-radius: 8px;&#10;  padding: 6px 12px;&#10;  font-weight: 600;&#10;  box-shadow: 0 2px 4px rgba(0,0,0,0.15);&#10;}&#10;.my-tile small { font-size: 0.8rem; margin-left: 4px; color: #444; }&#10;.my-score { font-weight: 700; color: #1565c0; margin-top: 0.5rem; }&#10;&#10;.other-player {&#10;  margin-bottom: 1.5rem; border: 1px solid #ddd; border-radius: 8px; padding: 10px; background: #fff;&#10;}&#10;.help-button, .error-button{&#10;  position: fixed;&#10;  bottom: 20px;&#10;  right: 20px;&#10;  background: #eee;&#10;  border: none;&#10;  border-radius: 50%;&#10;  width: 45px;&#10;  height: 45px;&#10;  font-size: 22px;&#10;  cursor: pointer;&#10;  color: #333;&#10;  box-shadow: 0 4px 10px rgba(0,0,0,0.25);&#10;}&#10;&#10;.error-button{&#10;  right: 70px;&#10;}&#10;.help-button:hover, .error-button:hover { background: #ddd; transform: scale(1.05); }&#10;&#10;&#10;.err { color: #b00020; margin-top: .5rem; font-weight: 600; }&#10;.turn { margin: .25rem 0 1rem; font-weight: 600; color: #333; }&#10;&lt;/style&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>