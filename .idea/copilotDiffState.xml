<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/backend/pom.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/pom.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&#10;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;&#10;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&#10;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;&#10;&#10;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&#10;&#10;    &lt;parent&gt;&#10;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;&#10;        &lt;version&gt;3.5.6&lt;/version&gt;&#10;        &lt;relativePath/&gt;&#10;    &lt;/parent&gt;&#10;&#10;    &lt;groupId&gt;nl.hva.ewa&lt;/groupId&gt;&#10;    &lt;artifactId&gt;regenwormen-backend&lt;/artifactId&gt;&#10;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&#10;    &lt;name&gt;regenwormen-backend&lt;/name&gt;&#10;    &lt;description&gt;EWA Regenwormen backend&lt;/description&gt;&#10;&#10;    &lt;properties&gt;&#10;        &lt;java.version&gt;21&lt;/java.version&gt;&#10;    &lt;/properties&gt;&#10;&#10;    &lt;dependencies&gt;&#10;        &lt;!-- Web (REST API) --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- ✅ WebSocket (STOMP messaging for real-time updates) --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;            &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- JPA/ORM --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;            &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- Database migrations (Flyway) --&gt;&#10;&lt;!--        &lt;dependency&gt;--&gt;&#10;&lt;!--            &lt;groupId&gt;org.flywaydb&lt;/groupId&gt;--&gt;&#10;&lt;!--            &lt;artifactId&gt;flyway-core&lt;/artifactId&gt;--&gt;&#10;&lt;!--        &lt;/dependency&gt;--&gt;&#10;&#10;        &lt;!-- PostgreSQL Flyway support --&gt;&#10;&lt;!--        &lt;dependency&gt;--&gt;&#10;&lt;!--            &lt;groupId&gt;org.flywaydb&lt;/groupId&gt;--&gt;&#10;&lt;!--            &lt;artifactId&gt;flyway-database-postgresql&lt;/artifactId&gt;--&gt;&#10;&lt;!--        &lt;/dependency&gt;--&gt;&#10;&#10;        &lt;!-- Production database --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.postgresql&lt;/groupId&gt;&#10;            &lt;artifactId&gt;postgresql&lt;/artifactId&gt;&#10;            &lt;scope&gt;runtime&lt;/scope&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- H2 Database (for development/testing) --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;com.h2database&lt;/groupId&gt;&#10;            &lt;artifactId&gt;h2&lt;/artifactId&gt;&#10;            &lt;scope&gt;runtime&lt;/scope&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- Lombok (reduce boilerplate) --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;&#10;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;&#10;            &lt;optional&gt;true&lt;/optional&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- Devtools (hot reload) --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;&#10;            &lt;scope&gt;runtime&lt;/scope&gt;&#10;            &lt;optional&gt;true&lt;/optional&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- Security (if using login/register endpoints) --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;            &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- Tests --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;&#10;            &lt;scope&gt;test&lt;/scope&gt;&#10;        &lt;/dependency&gt;&#10;    &lt;/dependencies&gt;&#10;&#10;    &lt;build&gt;&#10;        &lt;plugins&gt;&#10;            &lt;plugin&gt;&#10;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;&#10;            &lt;/plugin&gt;&#10;        &lt;/plugins&gt;&#10;    &lt;/build&gt;&#10;&#10;&lt;/project&gt;&#10;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&#10;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;&#10;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&#10;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;&#10;&#10;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&#10;&#10;    &lt;parent&gt;&#10;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;&#10;        &lt;version&gt;3.5.6&lt;/version&gt;&#10;        &lt;relativePath/&gt;&#10;    &lt;/parent&gt;&#10;&#10;    &lt;groupId&gt;nl.hva.ewa&lt;/groupId&gt;&#10;    &lt;artifactId&gt;regenwormen-backend&lt;/artifactId&gt;&#10;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&#10;    &lt;name&gt;regenwormen-backend&lt;/name&gt;&#10;    &lt;description&gt;EWA Regenwormen backend&lt;/description&gt;&#10;&#10;    &lt;properties&gt;&#10;        &lt;java.version&gt;21&lt;/java.version&gt;&#10;    &lt;/properties&gt;&#10;&#10;    &lt;dependencies&gt;&#10;        &lt;!-- Web (REST API) --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- ✅ WebSocket (STOMP messaging for real-time updates) --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;            &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- JPA/ORM --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;            &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- Database migrations (Flyway) --&gt;&#10;&lt;!--        &lt;dependency&gt;--&gt;&#10;&lt;!--            &lt;groupId&gt;org.flywaydb&lt;/groupId&gt;--&gt;&#10;&lt;!--            &lt;artifactId&gt;flyway-core&lt;/artifactId&gt;--&gt;&#10;&lt;!--        &lt;/dependency&gt;--&gt;&#10;&#10;        &lt;!-- PostgreSQL Flyway support --&gt;&#10;&lt;!--        &lt;dependency&gt;--&gt;&#10;&lt;!--            &lt;groupId&gt;org.flywaydb&lt;/groupId&gt;--&gt;&#10;&lt;!--            &lt;artifactId&gt;flyway-database-postgresql&lt;/artifactId&gt;--&gt;&#10;&lt;!--        &lt;/dependency&gt;--&gt;&#10;&#10;        &lt;!-- Production database --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.postgresql&lt;/groupId&gt;&#10;            &lt;artifactId&gt;postgresql&lt;/artifactId&gt;&#10;            &lt;scope&gt;runtime&lt;/scope&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- H2 Database (for development/testing) --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;com.h2database&lt;/groupId&gt;&#10;            &lt;artifactId&gt;h2&lt;/artifactId&gt;&#10;            &lt;scope&gt;runtime&lt;/scope&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- Lombok (reduce boilerplate) --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;&#10;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;&#10;            &lt;optional&gt;true&lt;/optional&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- Devtools (hot reload) --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;&#10;            &lt;scope&gt;runtime&lt;/scope&gt;&#10;            &lt;optional&gt;true&lt;/optional&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- Security (if using login/register endpoints) --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;            &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- Tests --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;&#10;            &lt;scope&gt;test&lt;/scope&gt;&#10;        &lt;/dependency&gt;&#10;    &lt;/dependencies&gt;&#10;&#10;    &lt;build&gt;&#10;        &lt;plugins&gt;&#10;            &lt;plugin&gt;&#10;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;&#10;            &lt;/plugin&gt;&#10;        &lt;/plugins&gt;&#10;    &lt;/build&gt;&#10;&#10;&lt;/project&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/src/main/java/nl/hva/ewa/regenwormen/controller/InGameController.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/src/main/java/nl/hva/ewa/regenwormen/controller/InGameController.java" />
              <option name="originalContent" value="package nl.hva.ewa.regenwormen.controller;&#10;&#10;import nl.hva.ewa.regenwormen.domain.Enum.DiceFace;&#10;import nl.hva.ewa.regenwormen.domain.Game;&#10;import nl.hva.ewa.regenwormen.domain.TilesPot;&#10;import nl.hva.ewa.regenwormen.domain.dto.EndTurnView;&#10;import nl.hva.ewa.regenwormen.domain.dto.TurnView;&#10;import nl.hva.ewa.regenwormen.service.InGameService;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.http.HttpStatus;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.web.bind.annotation.*;&#10;import lombok.extern.slf4j.Slf4j;&#10;&#10;@Slf4j&#10;@CrossOrigin(origins = &quot;http://localhost:5173&quot;)&#10;@RestController&#10;@RequestMapping(&quot;/ingame&quot;)&#10;public class InGameController {&#10;&#10;    private final InGameService service;&#10;&#10;    @Autowired&#10;    public InGameController(InGameService service) {&#10;        this.service = service;&#10;    }&#10;&#10;    // --------------------  Get full game state --------------------&#10;    @GetMapping(&quot;/{gameId}&quot;)&#10;    public ResponseEntity&lt;Game&gt; getGameState(@PathVariable String gameId) {&#10;        Game game = service.getGameById(gameId);&#10;        if (game == null) {&#10;            return ResponseEntity.notFound().build();&#10;        }&#10;        return ResponseEntity.ok(game);&#10;    }&#10;&#10;    // -------------------- ROUND 0 --------------------&#10;    @PostMapping(&quot;/{gameId}/startroll0/{username}&quot;)&#10;    public TurnView startAndRollRoundZero(@PathVariable String gameId, @PathVariable String username) {&#10;        return service.startAndRollRoundZero(gameId, username);&#10;    }&#10;&#10;    @PostMapping(&quot;/{gameId}/pickdice0/{username}&quot;)&#10;    public TurnView pickDiceFaceZero(@PathVariable String gameId,&#10;                                     @PathVariable String username,&#10;                                     @RequestBody DiceFace diceFace) {&#10;        return service.pickDiceFaceZero(gameId, username, diceFace);&#10;    }&#10;&#10;    @PostMapping(&quot;/{gameId}/reroll0/{username}&quot;)&#10;    public TurnView reRollZero(@PathVariable String gameId, @PathVariable String username) {&#10;        return service.reRollZero(gameId, username);&#10;    }&#10;&#10;    @PostMapping(&quot;/{gameId}/finishround0/{username}&quot;)&#10;    public EndTurnView finishRoundZero(@PathVariable String gameId, @PathVariable String username) {&#10;        return service.finishRoundZero(gameId, username);&#10;    }&#10;&#10;    // -------------------- NORMAL ROUNDS (&gt;= 1) --------------------&#10;    @PostMapping(&quot;/{gameId}/startroll/{username}&quot;)&#10;    public TurnView startAndRollRound(@PathVariable String gameId, @PathVariable String username) {&#10;        return service.startAndRollRound(gameId, username);&#10;    }&#10;&#10;    @PostMapping(&quot;/{gameId}/pickdice/{username}&quot;)&#10;    public TurnView pickDiceFace(@PathVariable String gameId,&#10;                                 @PathVariable String username,&#10;                                 @RequestBody DiceFace diceFace) {&#10;        return service.pickDiceFace(gameId, username, diceFace);&#10;    }&#10;&#10;    @PostMapping(&quot;/{gameId}/reroll/{username}&quot;)&#10;    public TurnView reRollRound(@PathVariable String gameId, @PathVariable String username) {&#10;        return service.reRoll(gameId, username);&#10;    }&#10;&#10;    @PostMapping(&quot;/{gameId}/finishround/{username}&quot;)&#10;    public EndTurnView finishRound(@PathVariable String gameId, @PathVariable String username) {&#10;        return service.finishRound(gameId, username);&#10;    }&#10;&#10;    // -------------------- TILE CLAIMING --------------------&#10;    @PostMapping(&quot;/{gameId}/claimfrompot/{username}&quot;)&#10;    public ResponseEntity&lt;Game&gt; claimFromPot(@PathVariable String gameId, @PathVariable String username) {&#10;        Game updated = service.claimTileFromPot(gameId, username);&#10;        return ResponseEntity.ok(updated);&#10;    }&#10;&#10;    // -------------------- TILE STEALING --------------------&#10;    @PostMapping(&quot;/{gameId}/stealFromPlayer/{username}&quot;)&#10;    public TilesPot stealTopTileFromPlayer(@PathVariable String gameId,&#10;                                           @PathVariable String username,&#10;                                           @RequestBody String victimUsername) {&#10;        return service.stealTopTileFromPlayer(gameId, username, victimUsername);&#10;    }&#10;    // --------------------  DISCONNECT &amp; LEAVE SECTION --------------------&#10;    /**&#10;     * Player verlaat expliciet naar lobby via USERNAME (geen timeout, direct verwijderd).&#10;     * POST /ingame/{gameId}/leave/{username}&#10;     */&#10;    @PostMapping(&quot;/{gameId}/leave/{username}&quot;)&#10;    public ResponseEntity&lt;Void&gt; playerLeaveGameByUsername(@PathVariable String gameId,&#10;                                                          @PathVariable String username) {&#10;        try {&#10;            log.info(&quot; Player LEAVE notification received - gameId: {} , username: {}&quot;, gameId, username);&#10;            service.handlePlayerLeaveGameByUsername(gameId, username);&#10;            log.info(&quot;✅ Player successfully left game&quot;);&#10;            return ResponseEntity.noContent().build();&#10;        } catch (Exception e) {&#10;            log.warn(&quot;❌ Error handling player leave: {}&quot;, e.getMessage());&#10;            return ResponseEntity.status(HttpStatus.BAD_REQUEST).build();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Player disconnected (via sendBeacon, WebSocket close, or browser close).&#10;     * POST /ingame/{gameId}/disconnect/{username}&#10;     *&#10;     * This starts a countdown timer. If player reconnects before timeout, they can continue.&#10;     * If timeout expires, they are removed from the game.&#10;     */&#10;    @PostMapping(&quot;/{gameId}/disconnect/{username}&quot;)&#10;    public ResponseEntity&lt;Void&gt; playerDisconnectByUsername(@PathVariable String gameId,&#10;                                                           @PathVariable String username) {&#10;        try {&#10;            log.info(&quot; Disconnect notification received - gameId: {}, username: {}&quot;, gameId, username);&#10;            service.handlePlayerDisconnectedByUsername(gameId, username);&#10;            log.info(&quot;⏳ Disconnect countdown started for player: {}&quot;, username);&#10;            return ResponseEntity.noContent().build();&#10;        } catch (Exception e) {&#10;            log.warn(&quot;❌ Error handling disconnect: {}&quot;, e.getMessage());&#10;            return ResponseEntity.status(HttpStatus.BAD_REQUEST).build();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Player reconnected successfully (via WebSocket reconnection).&#10;     * POST /ingame/{gameId}/reconnect/{username}&#10;     *&#10;     * Cancels the disconnect timeout and restarts the turn timer.&#10;     */&#10;    @PostMapping(&quot;/{gameId}/reconnect/{username}&quot;)&#10;    public ResponseEntity&lt;Void&gt; playerReconnectByUsername(@PathVariable String gameId,&#10;                                                          @PathVariable String username) {&#10;        try {&#10;            log.info(&quot;✅ Reconnect notification received - gameId: {}, username: {}&quot;, gameId, username);&#10;            service.handlePlayerReconnectedByUsername(gameId, username);&#10;            log.info(&quot; Player successfully reconnected: {}&quot;, username);&#10;            return ResponseEntity.noContent().build();&#10;        } catch (Exception e) {&#10;            log.warn(&quot;❌ Error handling reconnect: {}&quot;, e.getMessage());&#10;            return ResponseEntity.status(HttpStatus.BAD_REQUEST).build();&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package nl.hva.ewa.regenwormen.controller;&#10;&#10;import nl.hva.ewa.regenwormen.domain.Enum.DiceFace;&#10;import nl.hva.ewa.regenwormen.domain.Game;&#10;import nl.hva.ewa.regenwormen.domain.TilesPot;&#10;import nl.hva.ewa.regenwormen.domain.dto.EndTurnView;&#10;import nl.hva.ewa.regenwormen.domain.dto.TurnView;&#10;import nl.hva.ewa.regenwormen.service.InGameService;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.http.HttpStatus;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.web.bind.annotation.*;&#10;import lombok.extern.slf4j.Slf4j;&#10;&#10;@Slf4j&#10;@CrossOrigin(origins = &quot;http://localhost:5173&quot;)&#10;@RestController&#10;@RequestMapping(&quot;/ingame&quot;)&#10;public class InGameController {&#10;&#10;    private final InGameService service;&#10;&#10;    @Autowired&#10;    public InGameController(InGameService service) {&#10;        this.service = service;&#10;    }&#10;&#10;    // --------------------  Get full game state --------------------&#10;    @GetMapping(&quot;/{gameId}&quot;)&#10;    public ResponseEntity&lt;Game&gt; getGameState(@PathVariable String gameId) {&#10;        Game game = service.getGameById(gameId);&#10;        if (game == null) {&#10;            return ResponseEntity.notFound().build();&#10;        }&#10;        return ResponseEntity.ok(game);&#10;    }&#10;&#10;    // -------------------- ROUND 0 --------------------&#10;    @PostMapping(&quot;/{gameId}/startroll0/{username}&quot;)&#10;    public TurnView startAndRollRoundZero(@PathVariable String gameId, @PathVariable String username) {&#10;        return service.startAndRollRoundZero(gameId, username);&#10;    }&#10;&#10;    @PostMapping(&quot;/{gameId}/pickdice0/{username}&quot;)&#10;    public TurnView pickDiceFaceZero(@PathVariable String gameId,&#10;                                     @PathVariable String username,&#10;                                     @RequestBody DiceFace diceFace) {&#10;        return service.pickDiceFaceZero(gameId, username, diceFace);&#10;    }&#10;&#10;    @PostMapping(&quot;/{gameId}/reroll0/{username}&quot;)&#10;    public TurnView reRollZero(@PathVariable String gameId, @PathVariable String username) {&#10;        return service.reRollZero(gameId, username);&#10;    }&#10;&#10;    @PostMapping(&quot;/{gameId}/finishround0/{username}&quot;)&#10;    public EndTurnView finishRoundZero(@PathVariable String gameId, @PathVariable String username) {&#10;        return service.finishRoundZero(gameId, username);&#10;    }&#10;&#10;    // -------------------- NORMAL ROUNDS (&gt;= 1) --------------------&#10;    @PostMapping(&quot;/{gameId}/startroll/{username}&quot;)&#10;    public TurnView startAndRollRound(@PathVariable String gameId, @PathVariable String username) {&#10;        return service.startAndRollRound(gameId, username);&#10;    }&#10;&#10;    @PostMapping(&quot;/{gameId}/pickdice/{username}&quot;)&#10;    public TurnView pickDiceFace(@PathVariable String gameId,&#10;                                 @PathVariable String username,&#10;                                 @RequestBody DiceFace diceFace) {&#10;        return service.pickDiceFace(gameId, username, diceFace);&#10;    }&#10;&#10;    @PostMapping(&quot;/{gameId}/reroll/{username}&quot;)&#10;    public TurnView reRollRound(@PathVariable String gameId, @PathVariable String username) {&#10;        return service.reRoll(gameId, username);&#10;    }&#10;&#10;    @PostMapping(&quot;/{gameId}/finishround/{username}&quot;)&#10;    public EndTurnView finishRound(@PathVariable String gameId, @PathVariable String username) {&#10;        return service.finishRound(gameId, username);&#10;    }&#10;&#10;    // -------------------- TILE CLAIMING --------------------&#10;    @PostMapping(&quot;/{gameId}/claimfrompot/{username}&quot;)&#10;    public ResponseEntity&lt;Game&gt; claimFromPot(@PathVariable String gameId, @PathVariable String username) {&#10;        Game updated = service.claimTileFromPot(gameId, username);&#10;        return ResponseEntity.ok(updated);&#10;    }&#10;&#10;    // -------------------- TILE STEALING --------------------&#10;    @PostMapping(&quot;/{gameId}/stealFromPlayer/{username}&quot;)&#10;    public TilesPot stealTopTileFromPlayer(@PathVariable String gameId,&#10;                                           @PathVariable String username,&#10;                                           @RequestBody String victimUsername) {&#10;        return service.stealTopTileFromPlayer(gameId, username, victimUsername);&#10;    }&#10;    // --------------------  DISCONNECT &amp; LEAVE SECTION --------------------&#10;    /**&#10;     * Player verlaat expliciet naar lobby via USERNAME (geen timeout, direct verwijderd).&#10;     * POST /ingame/{gameId}/leave/{username}&#10;     */&#10;    @PostMapping(&quot;/{gameId}/leave/{username}&quot;)&#10;    public ResponseEntity&lt;Void&gt; playerLeaveGameByUsername(@PathVariable String gameId,&#10;                                                          @PathVariable String username) {&#10;        try {&#10;            log.info(&quot; Player LEAVE notification received - gameId: {} , username: {}&quot;, gameId, username);&#10;            service.handlePlayerLeaveGameByUsername(gameId, username);&#10;            log.info(&quot;✅ Player successfully left game&quot;);&#10;            return ResponseEntity.noContent().build();&#10;        } catch (Exception e) {&#10;            log.warn(&quot;❌ Error handling player leave: {}&quot;, e.getMessage());&#10;            return ResponseEntity.status(HttpStatus.BAD_REQUEST).build();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Player disconnected (via sendBeacon, WebSocket close, or browser close).&#10;     * POST /ingame/{gameId}/disconnect/{username}&#10;     *&#10;     * This starts a countdown timer. If player reconnects before timeout, they can continue.&#10;     * If timeout expires, they are removed from the game.&#10;     */&#10;    @PostMapping(&quot;/{gameId}/disconnect/{username}&quot;)&#10;    public ResponseEntity&lt;Void&gt; playerDisconnectByUsername(@PathVariable String gameId,&#10;                                                           @PathVariable String username) {&#10;        try {&#10;            log.info(&quot; Disconnect notification received - gameId: {}, username: {}&quot;, gameId, username);&#10;            service.handlePlayerDisconnectedByUsername(gameId, username);&#10;            log.info(&quot;⏳ Disconnect countdown started for player: {}&quot;, username);&#10;            return ResponseEntity.noContent().build();&#10;        } catch (Exception e) {&#10;            log.warn(&quot;❌ Error handling disconnect: {}&quot;, e.getMessage());&#10;            return ResponseEntity.status(HttpStatus.BAD_REQUEST).build();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Player reconnected successfully (via WebSocket reconnection).&#10;     * POST /ingame/{gameId}/reconnect/{username}&#10;     *&#10;     * Cancels the disconnect timeout and restarts the turn timer.&#10;     */&#10;    @PostMapping(&quot;/{gameId}/reconnect/{username}&quot;)&#10;    public ResponseEntity&lt;Void&gt; playerReconnectByUsername(@PathVariable String gameId,&#10;                                                          @PathVariable String username) {&#10;        try {&#10;            log.info(&quot;✅ Reconnect notification received - gameId: {}, username: {}&quot;, gameId, username);&#10;            service.handlePlayerReconnectedByUsername(gameId, username);&#10;            log.info(&quot; Player successfully reconnected: {}&quot;, username);&#10;            return ResponseEntity.noContent().build();&#10;        } catch (Exception e) {&#10;            log.warn(&quot;❌ Error handling reconnect: {}&quot;, e.getMessage());&#10;            return ResponseEntity.status(HttpStatus.BAD_REQUEST).build();&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/src/main/java/nl/hva/ewa/regenwormen/domain/Game.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/src/main/java/nl/hva/ewa/regenwormen/domain/Game.java" />
              <option name="originalContent" value="package nl.hva.ewa.regenwormen.domain;&#10;&#10;import nl.hva.ewa.regenwormen.domain.Enum.DiceFace;&#10;import nl.hva.ewa.regenwormen.domain.Enum.GameState;&#10;import nl.hva.ewa.regenwormen.domain.dto.*;&#10;&#10;import java.util.ArrayList;&#10;import java.util.Collections;&#10;import java.util.Comparator;&#10;import java.util.List;&#10;&#10;public class Game {&#10;    private final String id;&#10;    private String gameName;&#10;    private List&lt;Player&gt; players;&#10;&#10;    private int round = 0;&#10;    private GameState gameState;&#10;    private TilesPot tilesPot;&#10;    private List&lt;PlayersLeaderboardView&gt; leaderboard;&#10;&#10;    private int currentPlayersTurnIndex;&#10;    private int maxPlayers;&#10;&#10;    private static final int MIN_PLAYERS = 2;&#10;    private static final int MAX_PLAYERS = 8;&#10;    private static final int MAX_NAME_LENGTH = 16;&#10;&#10;    public Game(String gameName, int maxPlayers) {&#10;        setGameNameInternal(gameName);&#10;        setMaxPlayersInternal(maxPlayers);&#10;        this.id = Helpers.generateShortHexId(6);&#10;        this.players = new ArrayList&lt;&gt;();&#10;        this.currentPlayersTurnIndex = 0;&#10;        this.gameState = GameState.PRE_GAME;&#10;    }&#10;&#10;    // === GETTERS ===&#10;    public String getId() { return id; }&#10;    public String getGameName() { return gameName; }&#10;    public int getMaxPlayers() { return maxPlayers; }&#10;    public TilesPot getTilesPot() { return tilesPot; }&#10;    public List&lt;Player&gt; getPlayers() { return Collections.unmodifiableList(players); }&#10;    public int playersAmount() { return players.size(); }&#10;    public int getTurnIndex() { return currentPlayersTurnIndex; }&#10;    public GameState getGameState() { return gameState; }&#10;&#10;    // === SETTERS ===&#10;    public void setGameName(String gameName) { setGameNameInternal(gameName); }&#10;    public void setMaxPlayers(int maxPlayers) { setMaxPlayersInternal(maxPlayers); }&#10;    public void setGameState (GameState gameState) { this.gameState = gameState; }&#10;&#10;    // === PRE-GAME ===&#10;    public boolean addPlayer(Player player) {&#10;        if (player == null) return false;&#10;        if (findPlayerById(player.getId()) != null)&#10;            throw new IllegalArgumentException(&quot;Player already in game&quot;);&#10;        if (gameState != GameState.PRE_GAME)&#10;            throw new IllegalStateException(&quot;Game already started&quot;);&#10;        if (playersAmount() &gt;= maxPlayers)&#10;            throw new IllegalStateException(&quot;Max players reached&quot;);&#10;        return players.add(player);&#10;    }&#10;&#10;    public boolean leavePlayer(String playerId) {&#10;        if (playerId == null || playerId.isBlank())&#10;            throw new IllegalArgumentException(&quot;Player missing&quot;);&#10;&#10;        Player player = findPlayerById(playerId);&#10;        if (player == null) throw new IllegalArgumentException(&quot;Player not in game&quot;);&#10;&#10;        if (gameState == GameState.PRE_GAME) {&#10;            players.remove(player);&#10;            return true;&#10;        }&#10;&#10;        int leavingIdx = players.indexOf(player);&#10;        boolean wasCurrent = leavingIdx == currentPlayersTurnIndex;&#10;        boolean wasLast = leavingIdx == playersAmount() - 1;&#10;&#10;        if (gameState == GameState.PLAYING) {&#10;            player.returnAllTilesToPot();&#10;            if (wasCurrent) player.setEndTurn();&#10;        }&#10;&#10;        players.remove(leavingIdx);&#10;        if (gameState == GameState.PLAYING) {&#10;            if (players.size() &lt; MIN_PLAYERS) endGame();&#10;            if (leavingIdx &lt; currentPlayersTurnIndex) currentPlayersTurnIndex--;&#10;            if (wasLast &amp;&amp; wasCurrent) currentPlayersTurnIndex = 0;&#10;        }&#10;        return true;&#10;    }&#10;&#10;    public void startGame() {&#10;        if (gameState != GameState.PRE_GAME)&#10;            throw new IllegalStateException(&quot;Game already started/ended&quot;);&#10;        if (playersAmount() &lt; MIN_PLAYERS)&#10;            throw new IllegalStateException(&quot;Too few players&quot;);&#10;        if (playersAmount() &gt; MAX_PLAYERS)&#10;            throw new IllegalStateException(&quot;Too many players&quot;);&#10;&#10;        gameState = GameState.PLAYING;&#10;        tilesPot = new TilesPot();&#10;        round = 1;&#10;    }&#10;&#10;    // === ROUND ZERO ===&#10;    public TurnView startAndRollRoundZero(Player p) {&#10;        ensurePlaying();&#10;        List&lt;DiceFace&gt; options = throwDices(p);&#10;        return TurnView.turnViewThrown(p, options, hasMinValueToStop(p.getDiceRoll().getTakenScore()));&#10;    }&#10;&#10;    public TurnView reRollRoundZero(Player p) {&#10;        ensurePlaying();&#10;        List&lt;DiceFace&gt; options = throwDices(p);&#10;        if (options.isEmpty()) {&#10;            finishRoundZero(p);&#10;            return TurnView.bust(p);&#10;        }&#10;        return TurnView.turnViewThrown(p, options, hasMinValueToStop(p.getDiceRoll().getTakenScore()));&#10;    }&#10;&#10;    public TurnView pickDiceFaceZero(Player p, DiceFace face) {&#10;        int taken = p.getDiceRoll().pickDice(face);&#10;        return TurnView.turnViewChosen(p, hasMinValueToStop(taken));&#10;    }&#10;&#10;    public EndTurnView finishRoundZero(Player p) {&#10;        ensurePlaying();&#10;        Diceroll roll = p.getDiceRoll();&#10;        if (roll == null) throw new IllegalStateException(&quot;No active round zero roll&quot;);&#10;&#10;        if (roll.getBusted()) p.setDoublePointsTile(0);&#10;        else {&#10;            if (!roll.hasSpecial()) throw new IllegalStateException(&quot;Must have SPECIAL&quot;);&#10;            int score = roll.getTakenScore();&#10;            if (score &lt; 21) throw new IllegalArgumentException(&quot;Min 21 points&quot;);&#10;            p.setDoublePointsTile(score);&#10;        }&#10;        return EndTurnView.roundZero(p);&#10;    }&#10;&#10;    // === NORMAL ROUNDS ===&#10;    public TurnView startAndRollRound() {&#10;        ensurePlaying();&#10;        Player p = getCurrentPlayer();&#10;&#10;        //  IDEMPOTENT: If turn is already active (e.g., after reconnect), &#10;        // check if it's a stale turn that needs to be reset&#10;        if (p.getDiceRoll() != null) {&#10;            Diceroll existingRoll = p.getDiceRoll();&#10;            // If the roll has no available pickable faces (all chosen or bust),&#10;            // it's a stale turn from before disconnect - reset it&#10;            List&lt;DiceFace&gt; options = existingRoll.getPickableFaces();&#10;            if (options.isEmpty() &amp;&amp; !existingRoll.getBusted()) {&#10;                // Stale turn - reset and start fresh&#10;                p.setEndTurn();&#10;                p.setStartTurn(new Diceroll());&#10;                List&lt;DiceFace&gt; freshOptions = p.getDiceRoll().rollRemainingDice();&#10;                return TurnView.turnViewThrown(p, freshOptions, hasMinValueToStop(p.getDiceRoll().getTakenScore()));&#10;            } else {&#10;                // Turn is still valid - return current state&#10;                return TurnView.turnViewThrown(p, options, hasMinValueToStop(existingRoll.getTakenScore()));&#10;            }&#10;        }&#10;&#10;        // Otherwise start a new turn&#10;        p.setStartTurn(new Diceroll());&#10;        List&lt;DiceFace&gt; options = p.getDiceRoll().rollRemainingDice();&#10;        return TurnView.turnViewThrown(p, options, hasMinValueToStop(p.getDiceRoll().getTakenScore()));&#10;    }&#10;&#10;    public TurnView reRollRound() {&#10;        ensurePlaying();&#10;        Player p = getCurrentPlayer();&#10;&#10;        Diceroll roll = p.getDiceRoll();&#10;        if (roll == null) throw new IllegalStateException(&quot;No active roll&quot;);&#10;        if (roll.getTurnState().toString().equals(&quot;ENDED&quot;) || roll.getBusted()) {&#10;            handleBust(p);&#10;            return TurnView.bust(p);&#10;        }&#10;&#10;        List&lt;DiceFace&gt; options = roll.rollRemainingDice();&#10;        if (options.isEmpty()) {&#10;            handleBust(p);&#10;            return TurnView.bust(p);&#10;        }&#10;&#10;        return TurnView.turnViewThrown(p, options, hasMinValueToStop(roll.getTakenScore()));&#10;    }&#10;&#10;    public List&lt;DiceFace&gt; throwDices(Player player) {&#10;        if (player.getDiceRoll() == null) {&#10;            player.setStartTurn(new Diceroll());&#10;        }&#10;        return player.getDiceRoll().rollRemainingDice();&#10;    }&#10;&#10;    public TurnView pickDiceFace(DiceFace face) {&#10;        ensurePlaying();&#10;        Player p = getCurrentPlayer();&#10;        int taken = p.getDiceRoll().pickDice(face);&#10;        return TurnView.turnViewChosen(p, hasMinValueToStop(taken));&#10;    }&#10;&#10;    public EndTurnView finishRound() {&#10;        ensurePlaying();&#10;        Player p = getCurrentPlayer();&#10;        Diceroll roll = p.getDiceRoll();&#10;        if (roll == null) throw new IllegalStateException(&quot;No active roll&quot;);&#10;        if (roll.getBusted()) {&#10;            handleBust(p);&#10;            return EndTurnView.round(p, new ClaimOptions(p.getId(), List.of(), List.of()));&#10;        }&#10;&#10;        int score = roll.getTakenScore();&#10;        if (!hasMinValueToStop(score))&#10;            throw new IllegalStateException(&quot;Not enough points to pick something&quot;);&#10;&#10;        ClaimOptions options = buildClaimOptions(p);&#10;        return EndTurnView.round(p, options);&#10;    }&#10;&#10;    // === TILE CLAIMING ===&#10;    public Game claimFromPot() {&#10;        ensurePlaying();&#10;&#10;        Player player = getCurrentPlayer();&#10;        Diceroll roll = player.getDiceRoll();&#10;        if (roll == null || roll.getBusted())&#10;            throw new IllegalStateException(&quot;No valid roll to claim from.&quot;);&#10;        if (!roll.hasSpecial())&#10;            throw new IllegalStateException(&quot;Need at least one worm to claim a tile.&quot;);&#10;&#10;        int score = roll.getTakenScore();&#10;        Tile claimedTile = tilesPot.findHighestAvailableTileAtOrBelow(score);&#10;        if (claimedTile == null)&#10;            throw new IllegalArgumentException(&quot;No tile available at or below your score (&quot; + score + &quot;).&quot;);&#10;&#10;        // ✅ Give tile to player&#10;        claimedTile.takeTile(player);&#10;        player.addTile(claimedTile);&#10;&#10;        player.setEndTurn();&#10;        if (endGameCheck()) endGame();&#10;        else setNextPlayersTurn();&#10;&#10;        return this;&#10;    }&#10;&#10;    // === TILE STEALING ===&#10;    public TilesPot stealTopTile(String victimId) {&#10;        ensurePlaying();&#10;        Player thief = getCurrentPlayer();&#10;        Player victim = findPlayerById(victimId);&#10;        if (victim == null) throw new IllegalArgumentException(&quot;Victim not found&quot;);&#10;&#10;        Tile top = victim.getTopTile();&#10;        if (top == null) throw new IllegalArgumentException(&quot;Nothing to steal&quot;);&#10;&#10;        Diceroll roll = thief.getDiceRoll();&#10;        if (roll == null || roll.getBusted())&#10;            throw new IllegalStateException(&quot;No active roll&quot;);&#10;        if (!roll.hasSpecial())&#10;            throw new IllegalStateException(&quot;SPECIAL required&quot;);&#10;        if (roll.getTakenScore() != top.getValue())&#10;            throw new IllegalArgumentException(&quot;Score must equal victim’s top tile value&quot;);&#10;&#10;        victim.loseTopTileToStack();&#10;        top.takeTile(thief);&#10;        thief.addTile(top);&#10;        thief.setEndTurn();&#10;        setNextPlayersTurn();&#10;&#10;        return getTilesPot();&#10;    }&#10;&#10;    // === SUPPORT / ENDGAME ===&#10;    public void endGame() {&#10;        if (gameState != GameState.PLAYING) return;&#10;        gameState = GameState.ENDED;&#10;        calculateLeaderboard();&#10;&#10;    }&#10;&#10;    /**&#10;     * Zet de game volledig terug naar de beginstatus (voor nieuwe ronde of na te weinig spelers).&#10;     */&#10;    public void resetGame() {&#10;        // Zet alle tiles van spelers terug naar de pot&#10;        if (players != null) {&#10;            for (Player p : players) {&#10;                p.resetPlayer(); // Zorg dat deze methode bestaat in Player&#10;            }&#10;        }&#10;        // Reset tilespot&#10;        if (tilesPot != null) tilesPot.resetTiles(); // Zorg dat deze methode bestaat&#10;        // Reset ronde en beurt&#10;        round = 0;&#10;        currentPlayersTurnIndex = 0;&#10;        // Reset leaderboard&#10;        if (leaderboard != null) leaderboard.clear();&#10;        // Zet gameState op PRE_GAME zodat je opnieuw kunt starten&#10;        gameState = GameState.PRE_GAME;&#10;    }&#10;&#10;    private void ensurePlaying() {&#10;        if (gameState != GameState.PLAYING)&#10;            throw new IllegalStateException(&quot;Game not playing&quot;);&#10;    }&#10;&#10;    public Player getCurrentPlayer() {&#10;        if (players == null || players.isEmpty()) return null;&#10;        if (currentPlayersTurnIndex &lt; 0 || currentPlayersTurnIndex &gt;= players.size()) return null;&#10;        return players.get(currentPlayersTurnIndex);&#10;    }&#10;&#10;    public Player findPlayerById(String id) {&#10;        for (Player p : players)&#10;            if (p.getId().equals(id)) return p;&#10;        return null;&#10;    }&#10;&#10;    public void setNextPlayersTurn() {&#10;        int maxIndex = players.size() - 1;&#10;        if (currentPlayersTurnIndex == maxIndex) {&#10;            currentPlayersTurnIndex = 0;&#10;            round++;&#10;        } else currentPlayersTurnIndex++;&#10;    }&#10;&#10;    private boolean endGameCheck() {&#10;        return tilesPot.amountAvailableTiles() == 0;&#10;    }&#10;&#10;    private void handleBust(Player p) {&#10;        Tile top = p.getTopTile();&#10;        if (top != null) {&#10;            top.tileToPot();&#10;            p.loseTopTileToStack();&#10;        }&#10;        tilesPot.flipHighestAvailableTileIfAny();&#10;        p.setEndTurn();&#10;        if (endGameCheck()) endGame();&#10;        setNextPlayersTurn();&#10;    }&#10;&#10;    private ClaimOptions buildClaimOptions(Player p) {&#10;        Diceroll roll = p.getDiceRoll();&#10;        boolean hasSpecial = roll != null &amp;&amp; roll.hasSpecial();&#10;        if (!hasSpecial) return new ClaimOptions(p.getId(), List.of(), List.of());&#10;&#10;        int score = roll.getTakenScore();&#10;        List&lt;Integer&gt; claimablePot = new ArrayList&lt;&gt;();&#10;        for (Tile t : tilesPot.getAvailableTiles())&#10;            if (score &gt;= t.getValue()) claimablePot.add(t.getValue());&#10;&#10;        List&lt;StealOptions&gt; steals = new ArrayList&lt;&gt;();&#10;        for (Player victim : players) {&#10;            if (victim.equals(p)) continue;&#10;            Tile top = victim.getTopTile();&#10;            if (top != null &amp;&amp; score == top.getValue())&#10;                steals.add(new StealOptions(victim.getId(), top.getValue()));&#10;        }&#10;&#10;        return new ClaimOptions(p.getId(), claimablePot, steals);&#10;    }&#10;&#10;    private void calculateLeaderboard() {&#10;        List&lt;Player&gt; sorted = players.stream()&#10;                .sorted(Comparator.comparingInt(Player::getPoints).reversed())&#10;                .toList();&#10;&#10;        List&lt;PlayersLeaderboardView&gt; withRank = new ArrayList&lt;&gt;();&#10;        int rank = 0, lastScore = -1;&#10;        for (Player p : sorted) {&#10;            int pts = p.getPoints();&#10;            if (pts != lastScore) {&#10;                rank++;&#10;                lastScore = pts;&#10;            }&#10;            withRank.add(new PlayersLeaderboardView(p.getId(), p.getName(), pts, rank));&#10;        }&#10;        leaderboard = withRank;&#10;    }&#10;&#10;    private void setGameNameInternal(String name) {&#10;        if (name == null || name.isBlank() || name.length() &gt; MAX_NAME_LENGTH)&#10;            throw new IllegalArgumentException(&quot;Name must be 1–&quot; + MAX_NAME_LENGTH);&#10;        this.gameName = name.trim();&#10;    }&#10;&#10;    private void setMaxPlayersInternal(int max) {&#10;        if (max &lt; MIN_PLAYERS || max &gt; MAX_PLAYERS)&#10;            throw new IllegalArgumentException(&quot;Max players must be between 2 and 8&quot;);&#10;        this.maxPlayers = max;&#10;    }&#10;&#10;    public boolean hasPlayer(Player player) {&#10;        if (player == null) return false;&#10;        for (Player p : players) {&#10;            if (p.getId().equals(player.getId())) return true;&#10;        }&#10;        return false;&#10;    }&#10;&#10;    public boolean hasMinValueToStop(int points) {&#10;        int lowestPot = tilesPot.getLowestAvailableTileValue();&#10;        List&lt;Integer&gt; topTileValues = new ArrayList&lt;&gt;();&#10;        for (Player p : players) {&#10;            Tile t = p.getTopTile();&#10;            if (t != null) topTileValues.add(t.getValue());&#10;        }&#10;        return points &gt;= lowestPot || topTileValues.contains(points);&#10;    }&#10;&#10;    // === FORCE SKIP SUPPORT ===&#10;    /**&#10;     * Used when a player's turn expires or must be skipped.&#10;     * It safely advances to the next player without requiring&#10;     * any dice roll or points, cleans up dice state, and ensures&#10;     * the game stays valid.&#10;     */&#10;    public void forceNextPlayer() {&#10;        if (gameState != GameState.PLAYING) return;&#10;&#10;        Player current = getCurrentPlayer();&#10;        if (current != null) {&#10;            //  End their turn cleanly&#10;            current.setEndTurn();&#10;&#10;            //  Apply optional bust penalty logic&#10;            tilesPot.flipHighestAvailableTileIfAny();&#10;        }&#10;&#10;        // ⏩ Move to next player's turn&#10;        setNextPlayersTurn();&#10;    }&#10;&#10;&#10;    @Override&#10;    public boolean equals(Object obj) {&#10;        if (this == obj) return true;&#10;        if (!(obj instanceof Game)) return false;&#10;        return id.equals(((Game) obj).id);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package nl.hva.ewa.regenwormen.domain;&#10;&#10;import nl.hva.ewa.regenwormen.domain.Enum.DiceFace;&#10;import nl.hva.ewa.regenwormen.domain.Enum.GameState;&#10;import nl.hva.ewa.regenwormen.domain.dto.*;&#10;&#10;import java.util.ArrayList;&#10;import java.util.Collections;&#10;import java.util.Comparator;&#10;import java.util.List;&#10;&#10;public class Game {&#10;    private final String id;&#10;    private String gameName;&#10;    private List&lt;Player&gt; players;&#10;&#10;    private int round = 0;&#10;    private GameState gameState;&#10;    private TilesPot tilesPot;&#10;    private List&lt;PlayersLeaderboardView&gt; leaderboard;&#10;&#10;    private int currentPlayersTurnIndex;&#10;    private int maxPlayers;&#10;&#10;    private static final int MIN_PLAYERS = 2;&#10;    private static final int MAX_PLAYERS = 8;&#10;    private static final int MAX_NAME_LENGTH = 16;&#10;&#10;    public Game(String gameName, int maxPlayers) {&#10;        setGameNameInternal(gameName);&#10;        setMaxPlayersInternal(maxPlayers);&#10;        this.id = Helpers.generateShortHexId(6);&#10;        this.players = new ArrayList&lt;&gt;();&#10;        this.currentPlayersTurnIndex = 0;&#10;        this.gameState = GameState.PRE_GAME;&#10;    }&#10;&#10;    // === GETTERS ===&#10;    public String getId() { return id; }&#10;    public String getGameName() { return gameName; }&#10;    public int getMaxPlayers() { return maxPlayers; }&#10;    public TilesPot getTilesPot() { return tilesPot; }&#10;    public List&lt;Player&gt; getPlayers() { return Collections.unmodifiableList(players); }&#10;    public int playersAmount() { return players.size(); }&#10;    public int getTurnIndex() { return currentPlayersTurnIndex; }&#10;    public GameState getGameState() { return gameState; }&#10;&#10;    // === SETTERS ===&#10;    public void setGameName(String gameName) { setGameNameInternal(gameName); }&#10;    public void setMaxPlayers(int maxPlayers) { setMaxPlayersInternal(maxPlayers); }&#10;    public void setGameState (GameState gameState) { this.gameState = gameState; }&#10;&#10;    // === PRE-GAME ===&#10;    public boolean addPlayer(Player player) {&#10;        if (player == null) return false;&#10;        if (findPlayerById(player.getId()) != null)&#10;            throw new IllegalArgumentException(&quot;Player already in game&quot;);&#10;        if (gameState != GameState.PRE_GAME)&#10;            throw new IllegalStateException(&quot;Game already started&quot;);&#10;        if (playersAmount() &gt;= maxPlayers)&#10;            throw new IllegalStateException(&quot;Max players reached&quot;);&#10;        return players.add(player);&#10;    }&#10;&#10;    public boolean leavePlayer(String playerId) {&#10;        if (playerId == null || playerId.isBlank())&#10;            throw new IllegalArgumentException(&quot;Player missing&quot;);&#10;&#10;        Player player = findPlayerById(playerId);&#10;        if (player == null) throw new IllegalArgumentException(&quot;Player not in game&quot;);&#10;&#10;        if (gameState == GameState.PRE_GAME) {&#10;            players.remove(player);&#10;            return true;&#10;        }&#10;&#10;        int leavingIdx = players.indexOf(player);&#10;        boolean wasCurrent = leavingIdx == currentPlayersTurnIndex;&#10;        boolean wasLast = leavingIdx == playersAmount() - 1;&#10;&#10;        if (gameState == GameState.PLAYING) {&#10;            player.returnAllTilesToPot();&#10;            if (wasCurrent) player.setEndTurn();&#10;        }&#10;&#10;        players.remove(leavingIdx);&#10;        if (gameState == GameState.PLAYING) {&#10;            if (players.size() &lt; MIN_PLAYERS) endGame();&#10;            if (leavingIdx &lt; currentPlayersTurnIndex) currentPlayersTurnIndex--;&#10;            if (wasLast &amp;&amp; wasCurrent) currentPlayersTurnIndex = 0;&#10;        }&#10;        return true;&#10;    }&#10;&#10;    public void startGame() {&#10;        if (gameState != GameState.PRE_GAME)&#10;            throw new IllegalStateException(&quot;Game already started/ended&quot;);&#10;        if (playersAmount() &lt; MIN_PLAYERS)&#10;            throw new IllegalStateException(&quot;Too few players&quot;);&#10;        if (playersAmount() &gt; MAX_PLAYERS)&#10;            throw new IllegalStateException(&quot;Too many players&quot;);&#10;&#10;        gameState = GameState.PLAYING;&#10;        tilesPot = new TilesPot();&#10;        round = 1;&#10;    }&#10;&#10;    // === ROUND ZERO ===&#10;    public TurnView startAndRollRoundZero(Player p) {&#10;        ensurePlaying();&#10;        List&lt;DiceFace&gt; options = throwDices(p);&#10;        return TurnView.turnViewThrown(p, options, hasMinValueToStop(p.getDiceRoll().getTakenScore()));&#10;    }&#10;&#10;    public TurnView reRollRoundZero(Player p) {&#10;        ensurePlaying();&#10;        List&lt;DiceFace&gt; options = throwDices(p);&#10;        if (options.isEmpty()) {&#10;            finishRoundZero(p);&#10;            return TurnView.bust(p);&#10;        }&#10;        return TurnView.turnViewThrown(p, options, hasMinValueToStop(p.getDiceRoll().getTakenScore()));&#10;    }&#10;&#10;    public TurnView pickDiceFaceZero(Player p, DiceFace face) {&#10;        int taken = p.getDiceRoll().pickDice(face);&#10;        return TurnView.turnViewChosen(p, hasMinValueToStop(taken));&#10;    }&#10;&#10;    public EndTurnView finishRoundZero(Player p) {&#10;        ensurePlaying();&#10;        Diceroll roll = p.getDiceRoll();&#10;        if (roll == null) throw new IllegalStateException(&quot;No active round zero roll&quot;);&#10;&#10;        if (roll.getBusted()) p.setDoublePointsTile(0);&#10;        else {&#10;            if (!roll.hasSpecial()) throw new IllegalStateException(&quot;Must have SPECIAL&quot;);&#10;            int score = roll.getTakenScore();&#10;            if (score &lt; 21) throw new IllegalArgumentException(&quot;Min 21 points&quot;);&#10;            p.setDoublePointsTile(score);&#10;        }&#10;        return EndTurnView.roundZero(p);&#10;    }&#10;&#10;    // === NORMAL ROUNDS ===&#10;    public TurnView startAndRollRound() {&#10;        ensurePlaying();&#10;        Player p = getCurrentPlayer();&#10;&#10;        //  IDEMPOTENT: If turn is already active (e.g., after reconnect), &#10;        // check if it's a stale turn that needs to be reset&#10;        if (p.getDiceRoll() != null) {&#10;            Diceroll existingRoll = p.getDiceRoll();&#10;            // If the roll has no available pickable faces (all chosen or bust),&#10;            // it's a stale turn from before disconnect - reset it&#10;            List&lt;DiceFace&gt; options = existingRoll.getPickableFaces();&#10;            if (options.isEmpty() &amp;&amp; !existingRoll.getBusted()) {&#10;                // Stale turn - reset and start fresh&#10;                p.setEndTurn();&#10;                p.setStartTurn(new Diceroll());&#10;                List&lt;DiceFace&gt; freshOptions = p.getDiceRoll().rollRemainingDice();&#10;                return TurnView.turnViewThrown(p, freshOptions, hasMinValueToStop(p.getDiceRoll().getTakenScore()));&#10;            } else {&#10;                // Turn is still valid - return current state&#10;                return TurnView.turnViewThrown(p, options, hasMinValueToStop(existingRoll.getTakenScore()));&#10;            }&#10;        }&#10;&#10;        // Otherwise start a new turn&#10;        p.setStartTurn(new Diceroll());&#10;        List&lt;DiceFace&gt; options = p.getDiceRoll().rollRemainingDice();&#10;        return TurnView.turnViewThrown(p, options, hasMinValueToStop(p.getDiceRoll().getTakenScore()));&#10;    }&#10;&#10;    public TurnView reRollRound() {&#10;        ensurePlaying();&#10;        Player p = getCurrentPlayer();&#10;&#10;        Diceroll roll = p.getDiceRoll();&#10;        if (roll == null) throw new IllegalStateException(&quot;No active roll&quot;);&#10;        if (roll.getTurnState().toString().equals(&quot;ENDED&quot;) || roll.getBusted()) {&#10;            handleBust(p);&#10;            return TurnView.bust(p);&#10;        }&#10;&#10;        List&lt;DiceFace&gt; options = roll.rollRemainingDice();&#10;        if (options.isEmpty()) {&#10;            handleBust(p);&#10;            return TurnView.bust(p);&#10;        }&#10;&#10;        return TurnView.turnViewThrown(p, options, hasMinValueToStop(roll.getTakenScore()));&#10;    }&#10;&#10;    public List&lt;DiceFace&gt; throwDices(Player player) {&#10;        if (player.getDiceRoll() == null) {&#10;            player.setStartTurn(new Diceroll());&#10;        }&#10;        return player.getDiceRoll().rollRemainingDice();&#10;    }&#10;&#10;    public TurnView pickDiceFace(DiceFace face) {&#10;        ensurePlaying();&#10;        Player p = getCurrentPlayer();&#10;        int taken = p.getDiceRoll().pickDice(face);&#10;        return TurnView.turnViewChosen(p, hasMinValueToStop(taken));&#10;    }&#10;&#10;    public EndTurnView finishRound() {&#10;        ensurePlaying();&#10;        Player p = getCurrentPlayer();&#10;        Diceroll roll = p.getDiceRoll();&#10;        if (roll == null) throw new IllegalStateException(&quot;No active roll&quot;);&#10;        if (roll.getBusted()) {&#10;            handleBust(p);&#10;            return EndTurnView.round(p, new ClaimOptions(p.getId(), List.of(), List.of()));&#10;        }&#10;&#10;        int score = roll.getTakenScore();&#10;        if (!hasMinValueToStop(score))&#10;            throw new IllegalStateException(&quot;Not enough points to pick something&quot;);&#10;&#10;        ClaimOptions options = buildClaimOptions(p);&#10;        return EndTurnView.round(p, options);&#10;    }&#10;&#10;    // === TILE CLAIMING ===&#10;    public Game claimFromPot() {&#10;        ensurePlaying();&#10;&#10;        Player player = getCurrentPlayer();&#10;        Diceroll roll = player.getDiceRoll();&#10;        if (roll == null || roll.getBusted())&#10;            throw new IllegalStateException(&quot;No valid roll to claim from.&quot;);&#10;        if (!roll.hasSpecial())&#10;            throw new IllegalStateException(&quot;Need at least one worm to claim a tile.&quot;);&#10;&#10;        int score = roll.getTakenScore();&#10;        Tile claimedTile = tilesPot.findHighestAvailableTileAtOrBelow(score);&#10;        if (claimedTile == null)&#10;            throw new IllegalArgumentException(&quot;No tile available at or below your score (&quot; + score + &quot;).&quot;);&#10;&#10;        // ✅ Give tile to player&#10;        claimedTile.takeTile(player);&#10;        player.addTile(claimedTile);&#10;&#10;        player.setEndTurn();&#10;        if (endGameCheck()) endGame();&#10;        else setNextPlayersTurn();&#10;&#10;        return this;&#10;    }&#10;&#10;    // === TILE STEALING ===&#10;    public TilesPot stealTopTile(String victimId) {&#10;        ensurePlaying();&#10;        Player thief = getCurrentPlayer();&#10;        Player victim = findPlayerById(victimId);&#10;        if (victim == null) throw new IllegalArgumentException(&quot;Victim not found&quot;);&#10;&#10;        Tile top = victim.getTopTile();&#10;        if (top == null) throw new IllegalArgumentException(&quot;Nothing to steal&quot;);&#10;&#10;        Diceroll roll = thief.getDiceRoll();&#10;        if (roll == null || roll.getBusted())&#10;            throw new IllegalStateException(&quot;No active roll&quot;);&#10;        if (!roll.hasSpecial())&#10;            throw new IllegalStateException(&quot;SPECIAL required&quot;);&#10;        if (roll.getTakenScore() != top.getValue())&#10;            throw new IllegalArgumentException(&quot;Score must equal victim’s top tile value&quot;);&#10;&#10;        victim.loseTopTileToStack();&#10;        top.takeTile(thief);&#10;        thief.addTile(top);&#10;        thief.setEndTurn();&#10;        setNextPlayersTurn();&#10;&#10;        return getTilesPot();&#10;    }&#10;&#10;    // === SUPPORT / ENDGAME ===&#10;    public void endGame() {&#10;        if (gameState != GameState.PLAYING) return;&#10;        gameState = GameState.ENDED;&#10;        calculateLeaderboard();&#10;&#10;    }&#10;&#10;    /**&#10;     * Zet de game volledig terug naar de beginstatus (voor nieuwe ronde of na te weinig spelers).&#10;     */&#10;    public void resetGame() {&#10;        // Zet alle tiles van spelers terug naar de pot&#10;        if (players != null) {&#10;            for (Player p : players) {&#10;                p.resetPlayer(); // Zorg dat deze methode bestaat in Player&#10;            }&#10;        }&#10;        // Reset tilespot&#10;        if (tilesPot != null) tilesPot.resetTiles(); // Zorg dat deze methode bestaat&#10;        // Reset ronde en beurt&#10;        round = 0;&#10;        currentPlayersTurnIndex = 0;&#10;        // Reset leaderboard&#10;        if (leaderboard != null) leaderboard.clear();&#10;        // Zet gameState op PRE_GAME zodat je opnieuw kunt starten&#10;        gameState = GameState.PRE_GAME;&#10;    }&#10;&#10;    private void ensurePlaying() {&#10;        if (gameState != GameState.PLAYING)&#10;            throw new IllegalStateException(&quot;Game not playing&quot;);&#10;    }&#10;&#10;    public Player getCurrentPlayer() {&#10;        if (players == null || players.isEmpty()) return null;&#10;        if (currentPlayersTurnIndex &lt; 0 || currentPlayersTurnIndex &gt;= players.size()) return null;&#10;        return players.get(currentPlayersTurnIndex);&#10;    }&#10;&#10;    public Player findPlayerById(String id) {&#10;        for (Player p : players)&#10;            if (p.getId().equals(id)) return p;&#10;        return null;&#10;    }&#10;&#10;    public void setNextPlayersTurn() {&#10;        int maxIndex = players.size() - 1;&#10;        if (currentPlayersTurnIndex == maxIndex) {&#10;            currentPlayersTurnIndex = 0;&#10;            round++;&#10;        } else currentPlayersTurnIndex++;&#10;    }&#10;&#10;    private boolean endGameCheck() {&#10;        return tilesPot.amountAvailableTiles() == 0;&#10;    }&#10;&#10;    private void handleBust(Player p) {&#10;        Tile top = p.getTopTile();&#10;        if (top != null) {&#10;            top.tileToPot();&#10;            p.loseTopTileToStack();&#10;        }&#10;        tilesPot.flipHighestAvailableTileIfAny();&#10;        p.setEndTurn();&#10;        if (endGameCheck()) endGame();&#10;        setNextPlayersTurn();&#10;    }&#10;&#10;    private ClaimOptions buildClaimOptions(Player p) {&#10;        Diceroll roll = p.getDiceRoll();&#10;        boolean hasSpecial = roll != null &amp;&amp; roll.hasSpecial();&#10;        if (!hasSpecial) return new ClaimOptions(p.getId(), List.of(), List.of());&#10;&#10;        int score = roll.getTakenScore();&#10;        List&lt;Integer&gt; claimablePot = new ArrayList&lt;&gt;();&#10;        for (Tile t : tilesPot.getAvailableTiles())&#10;            if (score &gt;= t.getValue()) claimablePot.add(t.getValue());&#10;&#10;        List&lt;StealOptions&gt; steals = new ArrayList&lt;&gt;();&#10;        for (Player victim : players) {&#10;            if (victim.equals(p)) continue;&#10;            Tile top = victim.getTopTile();&#10;            if (top != null &amp;&amp; score == top.getValue())&#10;                steals.add(new StealOptions(victim.getId(), top.getValue()));&#10;        }&#10;&#10;        return new ClaimOptions(p.getId(), claimablePot, steals);&#10;    }&#10;&#10;    private void calculateLeaderboard() {&#10;        List&lt;Player&gt; sorted = players.stream()&#10;                .sorted(Comparator.comparingInt(Player::getPoints).reversed())&#10;                .toList();&#10;&#10;        List&lt;PlayersLeaderboardView&gt; withRank = new ArrayList&lt;&gt;();&#10;        int rank = 0, lastScore = -1;&#10;        for (Player p : sorted) {&#10;            int pts = p.getPoints();&#10;            if (pts != lastScore) {&#10;                rank++;&#10;                lastScore = pts;&#10;            }&#10;            withRank.add(new PlayersLeaderboardView(p.getId(), p.getName(), pts, rank));&#10;        }&#10;        leaderboard = withRank;&#10;    }&#10;&#10;    private void setGameNameInternal(String name) {&#10;        if (name == null || name.isBlank() || name.length() &gt; MAX_NAME_LENGTH)&#10;            throw new IllegalArgumentException(&quot;Name must be 1–&quot; + MAX_NAME_LENGTH);&#10;        this.gameName = name.trim();&#10;    }&#10;&#10;    private void setMaxPlayersInternal(int max) {&#10;        if (max &lt; MIN_PLAYERS || max &gt; MAX_PLAYERS)&#10;            throw new IllegalArgumentException(&quot;Max players must be between 2 and 8&quot;);&#10;        this.maxPlayers = max;&#10;    }&#10;&#10;    public boolean hasPlayer(Player player) {&#10;        if (player == null) return false;&#10;        for (Player p : players) {&#10;            if (p.getId().equals(player.getId())) return true;&#10;        }&#10;        return false;&#10;    }&#10;&#10;    public boolean hasMinValueToStop(int points) {&#10;        int lowestPot = tilesPot.getLowestAvailableTileValue();&#10;        List&lt;Integer&gt; topTileValues = new ArrayList&lt;&gt;();&#10;        for (Player p : players) {&#10;            Tile t = p.getTopTile();&#10;            if (t != null) topTileValues.add(t.getValue());&#10;        }&#10;        return points &gt;= lowestPot || topTileValues.contains(points);&#10;    }&#10;&#10;    // === FORCE SKIP SUPPORT ===&#10;    /**&#10;     * Used when a player's turn expires or must be skipped.&#10;     * It safely advances to the next player without requiring&#10;     * any dice roll or points, cleans up dice state, and ensures&#10;     * the game stays valid.&#10;     */&#10;    public void forceNextPlayer() {&#10;        if (gameState != GameState.PLAYING) return;&#10;&#10;        Player current = getCurrentPlayer();&#10;        if (current != null) {&#10;            //  End their turn cleanly&#10;            current.setEndTurn();&#10;&#10;            //  Apply optional bust penalty logic&#10;            tilesPot.flipHighestAvailableTileIfAny();&#10;        }&#10;&#10;        // ⏩ Move to next player's turn&#10;        setNextPlayersTurn();&#10;    }&#10;&#10;&#10;    @Override&#10;    public boolean equals(Object obj) {&#10;        if (this == obj) return true;&#10;        if (!(obj instanceof Game)) return false;&#10;        return id.equals(((Game) obj).id);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/src/main/java/nl/hva/ewa/regenwormen/domain/errorForm/ErrorRecord.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/src/main/java/nl/hva/ewa/regenwormen/domain/errorForm/ErrorRecord.java" />
              <option name="originalContent" value="package nl.hva.ewa.regenwormen.domain.errorForm;&#10;&#10;public class ErrorRecord {&#10;}&#10;" />
              <option name="updatedContent" value="package nl.hva.ewa.regenwormen.domain.errorForm;&#10;&#10;import nl.hva.ewa.regenwormen.domain.Enum.ErrorStatus;&#10;import nl.hva.ewa.regenwormen.domain.Enum.GameState;&#10;&#10;public record ErrorRecord(&#10;    String name,&#10;    String topic,&#10;    String category,&#10;    String priority,&#10;    String details,&#10;    GameState gameState,&#10;    String userId,&#10;    String gameId&#10;) {&#10;    // Record class voor eenvoudige error report data&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/src/main/java/nl/hva/ewa/regenwormen/service/GameGuards.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/src/main/java/nl/hva/ewa/regenwormen/service/GameGuards.java" />
              <option name="originalContent" value="package nl.hva.ewa.regenwormen.service;&#10;&#10;import nl.hva.ewa.regenwormen.domain.Game;&#10;import nl.hva.ewa.regenwormen.domain.Player;&#10;import nl.hva.ewa.regenwormen.repository.GameRepository;&#10;import nl.hva.ewa.regenwormen.repository.PlayerRepository;&#10;import org.springframework.http.HttpStatus;&#10;import org.springframework.stereotype.Component;&#10;import org.springframework.web.server.ResponseStatusException;&#10;&#10;@Component&#10;public class GameGuards {&#10;    private final GameRepository gameRepo;&#10;    private final PlayerRepository playerRepo;&#10;&#10;    public GameGuards(GameRepository gameRepo, PlayerRepository playerRepo) {&#10;        this.gameRepo = gameRepo;&#10;        this.playerRepo = playerRepo;&#10;    }&#10;&#10;    public Game getGameOrThrow(String gameId) {&#10;        return gameRepo.findById(gameId)&#10;                .orElseThrow(() -&gt; new ResponseStatusException(HttpStatus.NOT_FOUND,&#10;                        &quot;Game with id %s not found&quot;.formatted(gameId)));&#10;    }&#10;&#10;    public Player getPlayerOrThrow(String playerId) {&#10;        return playerRepo.findById(playerId)&#10;                .orElseThrow(() -&gt; new ResponseStatusException(HttpStatus.NOT_FOUND,&#10;                        &quot;Player with id %s not found&quot;.formatted(playerId)));&#10;    }&#10;&#10;    public void ensurePlayerInGame(Game game, Player player) {&#10;        if (!game.hasPlayer(player)) {&#10;            throw new ResponseStatusException(HttpStatus.FORBIDDEN,&#10;                    &quot;Player is not part of this game&quot;);&#10;        }&#10;    }&#10;&#10;    public void ensureYourTurn(Game game, Player player) {&#10;        if (!player.equals(game.getCurrentPlayer())) {&#10;            throw new ResponseStatusException(HttpStatus.FORBIDDEN,&#10;                    &quot;Not your turn&quot;);&#10;        }&#10;    }&#10;&#10;    //  Check if any player is disconnected (game should be blocked)&#10;    public void ensureNoPlayersDisconnected(Game game) {&#10;        boolean anyDisconnected = game.getPlayers().stream()&#10;                .anyMatch(p -&gt; p.getStatus() == Player.PlayerStatus.DISCONNECTED);&#10;&#10;        if (anyDisconnected) {&#10;            throw new ResponseStatusException(HttpStatus.CONFLICT,&#10;                    &quot;Game is paused - waiting for disconnected player to reconnect or timeout&quot;);&#10;        }&#10;    }&#10;&#10;}" />
              <option name="updatedContent" value="package nl.hva.ewa.regenwormen.service;&#13;&#10;&#13;&#10;import nl.hva.ewa.regenwormen.domain.Game;&#13;&#10;import nl.hva.ewa.regenwormen.domain.Player;&#13;&#10;import nl.hva.ewa.regenwormen.repository.GameRepository;&#13;&#10;import nl.hva.ewa.regenwormen.repository.PlayerRepository;&#13;&#10;import org.springframework.http.HttpStatus;&#13;&#10;import org.springframework.stereotype.Component;&#13;&#10;import org.springframework.web.server.ResponseStatusException;&#13;&#10;&#13;&#10;@Component&#13;&#10;public class GameGuards {&#13;&#10;    private final GameRepository gameRepo;&#13;&#10;    private final PlayerRepository playerRepo;&#13;&#10;&#13;&#10;    public GameGuards(GameRepository gameRepo, PlayerRepository playerRepo) {&#13;&#10;        this.gameRepo = gameRepo;&#13;&#10;        this.playerRepo = playerRepo;&#13;&#10;    }&#13;&#10;&#13;&#10;    public Game getGameOrThrow(String gameId) {&#13;&#10;        return gameRepo.findById(gameId)&#13;&#10;                .orElseThrow(() -&gt; new ResponseStatusException(HttpStatus.NOT_FOUND,&#13;&#10;                        &quot;Game with id %s not found&quot;.formatted(gameId)));&#13;&#10;    }&#13;&#10;&#13;&#10;    public Player getPlayerOrThrow(String playerId) {&#13;&#10;        return playerRepo.findById(playerId)&#13;&#10;                .orElseThrow(() -&gt; new ResponseStatusException(HttpStatus.NOT_FOUND,&#13;&#10;                        &quot;Player with id %s not found&quot;.formatted(playerId)));&#13;&#10;    }&#13;&#10;&#13;&#10;    public void ensurePlayerInGame(Game game, Player player) {&#13;&#10;        if (!game.hasPlayer(player)) {&#13;&#10;            throw new ResponseStatusException(HttpStatus.FORBIDDEN,&#13;&#10;                    &quot;Player is not part of this game&quot;);&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    public void ensureYourTurn(Game game, Player player) {&#13;&#10;        if (!player.equals(game.getCurrentPlayer())) {&#13;&#10;            throw new ResponseStatusException(HttpStatus.FORBIDDEN,&#13;&#10;                    &quot;Not your turn&quot;);&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    //  Check if any player is disconnected (game should be blocked)&#13;&#10;    public void ensureNoPlayersDisconnected(Game game) {&#13;&#10;        boolean anyDisconnected = game.getPlayers().stream()&#13;&#10;                .anyMatch(p -&gt; p.getStatus() == Player.PlayerStatus.DISCONNECTED);&#13;&#10;&#13;&#10;        if (anyDisconnected) {&#13;&#10;            throw new ResponseStatusException(HttpStatus.CONFLICT,&#13;&#10;                    &quot;Game is paused - waiting for disconnected player to reconnect or timeout&quot;);&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/src/main/resources/application.yml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/src/main/resources/application.yml" />
              <option name="originalContent" value="spring:&#10;  application:&#10;    name: regenwormen&#10;&#10;  datasource:&#10;    url: jdbc:postgresql://db.wxdfnqxpahfbhaxyrntk.supabase.co:5432/postgres&#10;    username: postgres&#10;    password: regenwormen&#10;&#10;  jpa:&#10;    hibernate:&#10;      ddl-auto: update&#10;    show-sql: true&#10;&#10;  profiles:&#10;    active: dev&#10;&#10;server:&#10;  port: 8080&#10;&#10;spring.servlet.multipart:&#10;  max-file-size: 10MB&#10;  max-request-size: 20MB&#10;" />
              <option name="updatedContent" value="spring:&#10;  application:&#10;    name: regenwormen&#10;&#10;  datasource:&#10;    url: jdbc:postgresql://db.wxdfnqxpahfbhaxyrntk.supabase.co:5432/postgres&#10;    username: postgres&#10;    password: regenwormen&#10;&#10;  jpa:&#10;    hibernate:&#10;      ddl-auto: update&#10;    show-sql: true&#10;&#10;  profiles:&#10;    active: dev&#10;&#10;server:&#10;  port: 8080&#10;&#10;spring.servlet.multipart:&#10;  max-file-size: 10MB&#10;  max-request-size: 20MB" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>